function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var uint8Array = Uint8Array;
var uint32Array = Uint32Array;
var pow = Math.pow;
var DEFAULT_STATE = new uint32Array(8);
var ROUND_CONSTANTS = [];
var LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];
var encoder = new TextEncoder();
function convertEndian(word) {
  return LittleEndian ? word >>> 24 | (word >>> 16 & 0xFF) << 8 | (word & 0xFF00) << 8 | word << 24 : word;
}
function rightRotate(word, bits) {
  return word >>> bits | word << 32 - bits;
}
function sha256(data) {
  var STATE = _toConsumableArray(DEFAULT_STATE);
  var legth = data.length;
  var bitLength = legth * 8;
  var newBitLength = 512 - (bitLength + 64) % 512 - 1 + bitLength + 65;
  var bytes = new uint8Array(newBitLength / 8);
  var words = new uint32Array(bytes.buffer);
  bytes.set(data, 0);
  bytes[legth] = 128;
  words[words.length - 1] = convertEndian(bitLength);
  var M = new uint32Array(64); // Move M here

  for (var block = 0; block < newBitLength / 32; block += 16) {
    var workingState = _toConsumableArray(STATE);
    for (var round = 0; round < 64; round++) {
      var MRound = void 0;
      if (round < 16) {
        MRound = convertEndian(words[block + round]);
      } else {
        var gamma0x = M[round - 15];
        var gamma1x = M[round - 2];
        MRound = M[round - 7] + M[round - 16] + (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ gamma0x >>> 3) + (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ gamma1x >>> 10);
      }
      M[round] = MRound = Math.trunc(MRound);
      var t1 = (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) + (workingState[4] & workingState[5] ^ ~workingState[4] & workingState[6]) + workingState[7] + MRound + ROUND_CONSTANTS[round];
      var t2 = (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) + (workingState[0] & workingState[1] ^ workingState[2] & (workingState[0] ^ workingState[1]));
      for (var i = 7; i > 0; i--) {
        workingState[i] = workingState[i - 1];
      }
      workingState[0] = Math.trunc(t1 + t2);
      workingState[4] = Math.trunc(workingState[4] + t1);
    }
    for (var _round = 0; _round < 8; _round++) {
      STATE[_round] = Math.trunc(STATE[_round] + workingState[_round]);
    }
  }
  return new uint8Array(new uint32Array(STATE.map(convertEndian)).buffer);
}
export function hex(bin) {
  return _toConsumableArray(bin).map(function (val) {
    return ('00' + val.toString(16)).slice(-2);
  }).join('');
}
export function hash(str) {
  return hex(sha256(encoder.encode(str)));
}
(function initialize() {
  var n = 2;
  var nPrime = 0;
  while (nPrime < 64) {
    var isPrime = true;
    for (var factor = 2; factor <= n / 2; factor++) {
      if (n % factor === 0) {
        isPrime = false;
      }
    }
    if (isPrime) {
      var getFractionalBits = function getFractionalBits(n) {
        return Math.trunc((n - Math.trunc(n)) * pow(2, 32));
      };
      if (nPrime < 8) {
        DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));
      }
      ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));
      nPrime++;
    }
    n++;
  }
})();