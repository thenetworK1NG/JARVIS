INVALID_CLIENT: Invalid redirect URI<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Voice Assistant Bot</title>
    
    <!-- TensorFlow.js for human detection -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 50%, #2c3e50 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
        }
        
        .main-panel {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        .side-panel {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
        }
        
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .bot-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            transition: all 0.3s ease;
            border: 4px solid transparent;
            position: relative;
            overflow: hidden;
        }
        
        .bot-avatar.idle {
            background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
            color: #7f8c8d;
            border-color: #bdc3c7;
        }
        
        .bot-avatar.listening {
            background: linear-gradient(135deg, #a8e6cf, #88d8a3);
            color: #27ae60;
            border-color: #27ae60;
            animation: pulse 2s infinite;
        }
        
        .bot-avatar.speaking {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
            color: #e17055;
            border-color: #e17055;
            animation: bounce 1s infinite;
        }
        
        .bot-avatar.processing {
            background: linear-gradient(135deg, #81ecec, #00b894);
            color: #00cec9;
            border-color: #00cec9;
            animation: spin 2s linear infinite;
        }
        
        .bot-avatar::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            transform: rotate(45deg);
            animation: shine 3s linear infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 20px rgba(39, 174, 96, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(39, 174, 96, 0); }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes shine {
            0% { transform: rotate(45deg) translate(-100%, -100%); }
            100% { transform: rotate(45deg) translate(100%, 100%); }
        }
        
        .controls {
            text-align: center;
            margin: 30px 0;
        }
        
        .btn {
            padding: 15px 30px;
            margin: 10px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s ease, height 0.3s ease;
        }
        
        .btn:hover::before {
            width: 100%;
            height: 100%;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(9, 132, 227, 0.3);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #fd79a8, #e84393);
            color: white;
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(232, 67, 147, 0.3);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .status-text {
            text-align: center;
            margin: 20px 0;
            font-size: 16px;
            color: #636e72;
            min-height: 50px;
        }
        
        .conversation {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
        }
        
        .message {
            margin: 15px 0;
            padding: 15px 20px;
            border-radius: 15px;
            position: relative;
            max-width: 80%;
            word-wrap: break-word;
            animation: fadeInUp 0.3s ease;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .message.user {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 5px;
        }
        
        .message.bot {
            background: linear-gradient(135deg, #a29bfe, #6c5ce7);
            color: white;
            margin-right: auto;
            border-bottom-left-radius: 5px;
        }
        
        .message-label {
            font-weight: 700;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 8px;
            opacity: 0.9;
            letter-spacing: 1px;
        }
        
        .message-time {
            font-size: 11px;
            opacity: 0.7;
            margin-top: 5px;
        }
        
        .capabilities {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .capabilities h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .capability-item {
            background: white;
            padding: 12px 16px;
            border-radius: 10px;
            margin: 8px 0;
            border-left: 4px solid #74b9ff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .settings {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
        }
        
        .settings h3 {
            margin-top: 0;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .form-group {
            margin: 15px 0;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .form-group select, .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 14px;
            box-sizing: border-box;
            transition: border-color 0.3s ease;
        }
        
        .form-group select:focus, .form-group input:focus {
            outline: none;
            border-color: #74b9ff;
        }
        
        .wake-words {
            background: linear-gradient(135deg, #fff4e6, #ffe8cc);
            border: 2px solid #ff9f43;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .wake-words h4 {
            margin-top: 0;
            color: #cc6d00;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .wake-word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        .wake-word {
            background: #ff9f43;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .stat-number {
            font-size: 24px;
            font-weight: 700;
            color: #74b9ff;
        }
        
        .stat-label {
            font-size: 12px;
            color: #636e72;
            text-transform: uppercase;
            margin-top: 5px;
        }
        
        /* Fullscreen button styles */
        .fullscreen-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(116, 185, 255, 0.3);
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .fullscreen-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(116, 185, 255, 0.4);
        }
        
        /* Fullscreen avatar overlay */
        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .fullscreen-overlay.active {
            display: flex;
        }
        
        .fullscreen-avatar {
            font-size: 15rem;
            margin-bottom: 2rem;
            transition: all 0.5s ease;
            text-shadow: 0 0 50px rgba(255, 255, 255, 0.3);
        }
        
        .fullscreen-status {
            font-size: 2rem;
            color: white;
            text-align: center;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        
        .fullscreen-substatus {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            max-width: 600px;
            margin-bottom: 2rem;
        }
        
        .fullscreen-hint {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            max-width: 500px;
            margin-top: 1rem;
            font-style: italic;
        }
        
        .back-btn {
            position: absolute;
            top: 30px;
            left: 30px;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 24px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .settings-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 24px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .lock-btn {
            position: absolute;
            top: 30px;
            right: 100px;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 24px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .lock-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        /* Avatar states for fullscreen */
        .fullscreen-avatar.idle { color: #74b9ff; }
        .fullscreen-avatar.listening { 
            color: #00b894; 
            animation: pulse 2s infinite;
        }
        .fullscreen-avatar.speaking { 
            color: #e17055; 
            animation: bounce 1s infinite;
        }
        .fullscreen-avatar.processing { 
            color: #fdcb6e; 
            animation: spin 2s linear infinite;
        }
        .fullscreen-avatar.sleeping { color: #636e72; }
        .fullscreen-avatar.interrupted { 
            color: #d63031; 
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        /* Smart View Overlay Styles */
        .smart-view-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 10000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .smart-view-overlay.active {
            display: block;
            opacity: 1;
        }
        
        .smart-view-content {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .smart-view-header {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10001;
            display: flex;
            gap: 10px;
        }
        
        .smart-close-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .smart-close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .smart-instructions {
            background: rgba(110, 142, 251, 0.2);
            border: 1px solid rgba(110, 142, 251, 0.3);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        /* Camera View Styles */
        .camera-container {
            position: absolute;
            top: 30px;
            right: 100px;
            width: 320px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 1001;
        }
        
        .camera-header {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            font-weight: 600;
        }
        
        .camera-close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s ease;
        }
        
        .camera-close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        #cameraVideo {
            width: 100%;
            height: 240px;
            object-fit: cover;
            display: block;
        }
        
        .camera-controls {
            padding: 10px;
            text-align: center;
        }
        
        .camera-btn {
            background: linear-gradient(135deg, #fd79a8, #e84393);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .camera-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(232, 67, 147, 0.3);
        }
        
        .detection-info {
            margin-top: 5px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 10px;
            text-align: center;
        }
        
        .motion-info {
            margin-top: 5px;
            color: rgba(0, 184, 148, 0.9);
            font-size: 10px;
            text-align: center;
        }
        
        .motion-btn {
            margin-left: 5px;
            font-size: 11px;
            padding: 6px 12px;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .side-panel {
                position: static;
            }
            
            .fullscreen-avatar {
                font-size: 10rem;
            }
            
            .fullscreen-status {
                font-size: 1.5rem;
            }
            
            .fullscreen-substatus {
                font-size: 1rem;
                padding: 0 20px;
            }
            
            .camera-container {
                top: 100px;
                right: 20px;
                left: 20px;
                width: auto;
            }
        }
        
        /* Intro Video Overlay */
        .intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease-in-out;
        }
        
        .intro-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .intro-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .intro-controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
        }
        
        .intro-skip, .intro-unmute {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .intro-skip:hover, .intro-unmute:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .intro-unmute.sound-enabled {
            background: rgba(76, 175, 80, 0.3);
            border-color: rgba(76, 175, 80, 0.5);
        }
        
        .intro-unmute {
            display: none; /* Initially hidden, shown if autoplay with sound fails */
        }
        
        .intro-play-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .intro-play-prompt h2 {
            margin: 0 0 15px 0;
            font-size: 24px;
        }
        
        .intro-play-prompt p {
            margin: 0;
            font-size: 16px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <!-- Intro Video Overlay -->
    <div class="intro-overlay" id="introOverlay">
        <video class="intro-video" id="introVideo" autoplay preload="auto">
            <source src="intro.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>
        <div class="intro-play-prompt" id="introPlayPrompt" style="display: none;">
            <div style="text-align: center; color: white;">
                <h2>üé¨ Click to Play Intro</h2>
                <p>Your browser requires user interaction to play video with sound</p>
            </div>
        </div>
        <div class="intro-controls">
            <button class="intro-unmute" id="introUnmute" onclick="toggleIntroSound()" style="margin-right: 10px;">üîä Enable Sound</button>
            <button class="intro-skip" onclick="skipIntro()">Skip Intro</button>
        </div>
    </div>
    
    <div class="container">
        <div class="main-panel">
            <div class="fullscreen-btn" onclick="openFullscreenAvatar()">üîç</div>
            <h1>ü§ñ Advanced Voice Assistant</h1>
            <p class="subtitle">Your intelligent voice companion with advanced conversational abilities</p>
            
            <div class="bot-avatar idle" id="botAvatar">
                ü§ñ
            </div>
            
            <div class="status-text" id="statusText">
                Ready to start your voice assistant journey...
            </div>
            
            <div class="controls">
                <button class="btn btn-primary" id="startBtn" onclick="startBot()">
                    üéôÔ∏è Activate Assistant
                </button>
                <button class="btn btn-danger" id="stopBtn" onclick="stopBot()" disabled>
                    ‚èπÔ∏è Deactivate Assistant
                </button>
                <button class="btn btn-secondary" id="pushToTalkBtn" style="display: none;" 
                        ontouchstart="startPushToTalk(event)" 
                        ontouchend="stopPushToTalk(event)"
                        onmousedown="startPushToTalk(event)" 
                        onmouseup="stopPushToTalk(event)">
                    üé§ Hold to Talk
                </button>
            </div>
            
            <div class="conversation" id="conversation">
                <div class="message bot">
                    <div class="message-label">Assistant</div>
                    Welcome! I'm your advanced voice assistant. I can help you with various tasks, answer questions, tell jokes, provide information, and engage in natural conversation. Say one of my wake words to get started!
                    <div class="message-time" id="welcome-time"></div>
                </div>
            </div>
        </div>
        
        <div class="side-panel">
            <div class="capabilities">
                <h3>ÔøΩ Custom Commands</h3>
                <div class="capability-item">
                    <strong>ÔøΩ Add Commands</strong><br>
                    Use the settings panel to add your own voice commands and responses
                </div>
                <div class="capability-item">
                    <strong>ÔøΩÔ∏è Current Commands</strong><br>
                    <span id="commandsList">hello, help, open smart view, close smart view (+ built-in: time, date, camera controls)</span>
                </div>
                <div class="capability-item">
                    <strong>‚ö° Dynamic</strong><br>
                    Commands update instantly without restarting the bot
                </div>
            </div>
            
            <div class="wake-words">
                <h4>üîî Wake, Sleep & Interrupt Words</h4>
                <p><strong>Wake Words:</strong> <span id="wakeWordsList">hey bot, hello bot, assistant, computer</span></p>
                <p><strong>Sleep Words:</strong> <span id="sleepWordsList">sleep, go to sleep, sleep mode, rest, standby</span></p>
                <p><strong>Interrupt Words:</strong> <span id="interruptWordsList">stop, stop speaking, be quiet, shut up, halt, interrupt, pause, cancel</span></p>
            </div>
            
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number" id="conversationCount">0</div>
                    <div class="stat-label">Conversations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="responseCount">0</div>
                    <div class="stat-label">Responses</div>
                </div>
            </div>
            
            <div class="settings">
                <h3>‚öôÔ∏è Voice Settings</h3>
                
                <div class="form-group">
                    <label for="botVoice">Assistant Voice:</label>
                    <select id="botVoice" onchange="testVoice()">
                        <option value="en-US-AriaNeural">Aria (US Female)</option>
                        <option value="en-US-GuyNeural">Guy (US Male)</option>
                        <option value="en-GB-SoniaNeural">Sonia (UK Female)</option>
                        <option value="en-GB-RyanNeural">Ryan (UK Male)</option>
                        <option value="en-US-JennyNeural">Jenny (US Female)</option>
                        <option value="en-US-DavisNeural">Davis (US Male)</option>
                    </select>
                    <button type="button" onclick="testVoice()" style="margin-top: 8px; padding: 10px 16px; background: linear-gradient(135deg, #a29bfe, #6c5ce7); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: 600;">üîä Test Voice</button>
                </div>
                
                <div class="form-group">
                    <label for="botLanguage">Recognition Language:</label>
                    <select id="botLanguage">
                        <option value="en-US">English (US)</option>
                        <option value="en-GB">English (UK)</option>
                        <option value="en-CA">English (Canada)</option>
                        <option value="en-AU">English (Australia)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="botSpeed">Speech Speed:</label>
                    <select id="botSpeed">
                        <option value="x-slow">Extra Slow</option>
                        <option value="slow">Slow</option>
                        <option value="medium" selected>Medium</option>
                        <option value="fast">Fast</option>
                        <option value="x-fast">Extra Fast</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="botPitch">Voice Pitch:</label>
                    <select id="botPitch" onchange="updatePitchDisplay()">
                        <option value="0.1">Extra Low (0.1)</option>
                        <option value="0.3">Very Low (0.3)</option>
                        <option value="0.5">Low (0.5)</option>
                        <option value="0.8">Medium Low (0.8)</option>
                        <option value="1.0" selected>Normal (1.0)</option>
                        <option value="1.2">Medium High (1.2)</option>
                        <option value="1.5">High (1.5)</option>
                        <option value="1.8">Very High (1.8)</option>
                        <option value="2.0">Extra High (2.0)</option>
                    </select>
                    <div id="pitchDisplay" style="margin-top: 8px; padding: 8px; background: #f8f9fa; border-radius: 5px; font-size: 12px; color: #666;">
                        Current pitch: 1.0 (Normal)
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="microphoneSelect">Microphone:</label>
                    <select id="microphoneSelect">
                        <option value="default">Default Microphone</option>
                    </select>
                    <button type="button" onclick="refreshMicrophones()" style="margin-top: 8px; padding: 10px 16px; background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: 600;">üîÑ Refresh Microphones</button>
                </div>
                
                <div class="form-group">
                    <label for="timeoutSelect">Listen Timeout (after speaking):</label>
                    <select id="timeoutSelect" onchange="updateTimeoutDisplay()">
                        <option value="500">0.5 seconds</option>
                        <option value="1000">1 second</option>
                        <option value="1500">1.5 seconds</option>
                        <option value="2000" selected>2 seconds</option>
                        <option value="2500">2.5 seconds</option>
                        <option value="3000">3 seconds</option>
                        <option value="4000">4 seconds</option>
                        <option value="5000">5 seconds</option>
                    </select>
                    <div id="timeoutDisplay" style="margin-top: 8px; padding: 8px; background: #f8f9fa; border-radius: 5px; font-size: 12px; color: #666;">
                        Bot will wait 2.0 seconds before listening again
                    </div>
                </div>
            </div>
            
            <div class="settings">
                <h3>üéØ Custom Commands</h3>
                
                <div class="form-group">
                    <label for="commandInput">Command Trigger:</label>
                    <input type="text" id="commandInput" placeholder="e.g. weather, joke, news" style="margin-bottom: 8px;">
                </div>
                
                <div class="form-group">
                    <label for="responseInput">Response:</label>
                    <textarea id="responseInput" placeholder="Enter the response for this command..." style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 80px; resize: vertical;"></textarea>
                </div>
                
                <button type="button" onclick="addCommand()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #00b894, #00cec9); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 600; margin-bottom: 15px;">‚ûï Add Command</button>
                
                <div class="form-group">
                    <label>Current Commands:</label>
                    <div id="commandsDisplay" style="background: white; border: 2px solid #e1e5e9; border-radius: 10px; padding: 15px; max-height: 200px; overflow-y: auto;">
                        <!-- Commands will be displayed here -->
                    </div>
                </div>
                
                <button type="button" onclick="clearAllCommands()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #fd79a8, #e84393); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 12px; font-weight: 600;">üóëÔ∏è Clear All Commands</button>
            </div>
            
            <div class="settings">
                <h3>üïí Time & Date Responses</h3>
                
                <div class="form-group">
                    <label for="timeResponseFormat">Time Response Format:</label>
                    <textarea id="timeResponseFormat" placeholder="The current time is {time}" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 60px; resize: vertical;" onchange="saveSettings();"></textarea>
                    <small style="color: #666; margin-top: 5px; display: block;">Use {time} as placeholder for the actual time. Examples: "It's {time}", "The time is currently {time}", "Right now it's {time}"</small>
                </div>
                
                <div class="form-group">
                    <label for="dateResponseFormat">Date Response Format:</label>
                    <textarea id="dateResponseFormat" placeholder="Today is {date}" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 60px; resize: vertical;" onchange="saveSettings();"></textarea>
                    <small style="color: #666; margin-top: 5px; display: block;">Use {date} as placeholder for the actual date. Examples: "Today is {date}", "The date is {date}", "We're currently on {date}"</small>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px;">
                    <button type="button" onclick="testTimeResponse()" style="padding: 10px; background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 12px; font-weight: 600;">üïí Test Time</button>
                    <button type="button" onclick="testDateResponse()" style="padding: 10px; background: linear-gradient(135deg, #a29bfe, #6c5ce7); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 12px; font-weight: 600;">üìÖ Test Date</button>
                </div>
                
                <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 10px; border-left: 4px solid #74b9ff;">
                    <strong>Built-in Time/Date Commands:</strong><br>
                    <small style="color: #666;">
                        These work automatically: "time", "what time", "current time", "date", "what date", "current date", "today"<br>
                        Your custom format will be used for all time/date responses.
                    </small>
                </div>
                
                <button type="button" onclick="resetTimeeDateFormats()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #ffeaa7, #fdcb6e); color: #2d3436; border: none; border-radius: 10px; cursor: pointer; font-size: 12px; font-weight: 600; margin-top: 10px;">‚Ü©Ô∏è Reset to Defaults</button>
            </div>
            
            <div class="settings">
                <h3>ÔøΩ Mobile Optimization</h3>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="mobileOptimization" onchange="toggleMobileOptimization(); saveSettings();" style="transform: scale(1.2);">
                        <strong>Enable Mobile Optimization</strong>
                    </label>
                    <small style="color: #666; margin-top: 5px; display: block;">
                        Reduces microphone opening/closing on mobile devices to prevent audio feedback and improve battery life. 
                        Automatically detected: <span id="deviceType"></span>
                    </small>
                </div>
                
                <div class="form-group" id="mobilePushToTalkGroup" style="display: none;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="mobilePushToTalk" onchange="toggleMobilePushToTalk(); saveSettings();" style="transform: scale(1.2);">
                        <strong>üì± Push-to-Talk Mode (Desktop Only Option)</strong>
                    </label>
                    <small style="color: #666; margin-top: 5px; display: block;">
                        Touch and hold the microphone button to speak, release to stop. <strong>Note: Push-to-talk is automatically enabled and required on mobile devices.</strong>
                    </small>
                </div>
                
                <div class="form-group" id="mobileAutoSleepGroup" style="display: none;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="disableMobileAutoSleep" onchange="saveSettings();" style="transform: scale(1.2);">
                        <strong>üîÑ Disable Auto-Sleep on Mobile</strong>
                    </label>
                    <small style="color: #666; margin-top: 5px; display: block;">
                        Keeps the assistant continuously listening on mobile without auto-sleep timeout. Only manual sleep commands will work.
                    </small>
                </div>
                
                <div id="mobileOptDetails" style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 10px; border-left: 4px solid #00b894;">
                    <strong>Mobile Optimization Features:</strong><br>
                    <small style="color: #666;">
                        ‚Ä¢ <strong>Mandatory push-to-talk on mobile</strong> (no continuous listening)<br>
                        ‚Ä¢ Voice activity detection disabled<br>
                        ‚Ä¢ Optional auto-sleep disable<br>
                        ‚Ä¢ Battery-friendly operation<br>
                        ‚Ä¢ No microphone permission prompts during normal use<br>
                        ‚Ä¢ Complete elimination of audio feedback issues
                    </small>
                </div>
            </div>
            
            <div class="settings">
                <h3>ÔøΩüîî Wake, Sleep & Interrupt Words</h3>
                
                <div class="form-group">
                    <label for="wakeWordInput">Wake Words (comma-separated):</label>
                    <textarea id="wakeWordInput" placeholder="hey bot, hello bot, assistant, computer" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 60px; resize: vertical;"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="sleepWordInput">Sleep Words (comma-separated):</label>
                    <textarea id="sleepWordInput" placeholder="sleep, go to sleep, sleep mode, rest, standby" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 60px; resize: vertical;"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="interruptWordInput">Interrupt Words (comma-separated):</label>
                    <textarea id="interruptWordInput" placeholder="stop, stop speaking, be quiet, shut up, halt, interrupt, pause, cancel" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 60px; resize: vertical;"></textarea>
                </div>
                
                <button type="button" onclick="updateWakeWords()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #a29bfe, #6c5ce7); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 600; margin-bottom: 10px;">üîÑ Update Wake/Sleep/Interrupt Words</button>
                
                <button type="button" onclick="resetWakeWords()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #ffeaa7, #fdcb6e); color: #2d3436; border: none; border-radius: 10px; cursor: pointer; font-size: 12px; font-weight: 600;">‚Ü©Ô∏è Reset to Defaults</button>
                
                <div style="margin-top: 20px;">
                    <h4>Individual Word Management</h4>
                    
                    <div style="margin-bottom: 15px;">
                        <strong>Wake Words:</strong>
                        <div id="wakeWordsDisplay" style="background: white; border: 2px solid #e1e5e9; border-radius: 10px; padding: 10px; margin-top: 5px; max-height: 150px; overflow-y: auto;">
                            <!-- Wake words will be displayed here -->
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <strong>Sleep Words:</strong>
                        <div id="sleepWordsDisplay" style="background: white; border: 2px solid #e1e5e9; border-radius: 10px; padding: 10px; margin-top: 5px; max-height: 150px; overflow-y: auto;">
                            <!-- Sleep words will be displayed here -->
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <strong>Interrupt Words:</strong>
                        <div id="interruptWordsDisplay" style="background: white; border: 2px solid #e1e5e9; border-radius: 10px; padding: 10px; margin-top: 5px; max-height: 150px; overflow-y: auto;">
                            <!-- Interrupt words will be displayed here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="settings">
                <h3>üß† AI Integration (Optional)</h3>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="useOllama" onchange="toggleOllamaSettings(); saveSettings();" style="transform: scale(1.2);">
                        <strong>Use Local AI (Ollama)</strong>
                    </label>
                    <small style="color: #666; margin-top: 5px; display: block;">Enable intelligent responses using your local Ollama model</small>
                </div>
                
                <div id="ollamaSettings" style="display: none;">
                    <div class="form-group">
                        <label for="ollamaUrl">Ollama URL:</label>
                        <input type="text" id="ollamaUrl" value="http://localhost:11434" placeholder="http://localhost:11434" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;" onchange="saveSettings();">
                    </div>
                    
                    <div class="form-group">
                        <label for="ollamaModel">AI Model:</label>
                        <select id="ollamaModel" onchange="saveSettings();" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;">
                            <option value="tinyllama">tinyllama (default)</option>
                        </select>
                    </div>
                    
                    <button type="button" onclick="testOllamaConnection()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #a29bfe, #6c5ce7); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 600; margin-bottom: 10px;">üîó Test Connection</button>
                    
                    <div id="ollamaStatus" style="padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 12px; color: #666; text-align: center;">
                        Not tested yet
                    </div>
                    
                    <div style="margin-top: 15px; padding: 12px; background: #e8f5e8; border: 2px solid #27ae60; border-radius: 10px; font-size: 12px; color: #2d3436;">
                        <strong>üí° How it works:</strong><br>
                        ‚Ä¢ Commands still work first (time, date, custom commands)<br>
                        ‚Ä¢ AI handles everything else with intelligent responses<br>
                        ‚Ä¢ Requires Ollama running locally with tinyllama model
                    </div>
                </div>
            </div>
            
            <div class="settings">
                <h3>üéµ Spotify Integration</h3>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="useSpotify" onchange="toggleSpotifySettings(); saveSettings();" style="transform: scale(1.2);">
                        <strong>Enable Spotify Control</strong>
                    </label>
                    <small style="color: #666; margin-top: 5px; display: block;">Control Spotify playback with voice commands</small>
                </div>
                
                <div id="spotifySettings" style="display: none;">
                    <div style="margin-bottom: 15px; padding: 12px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 10px; font-size: 12px; color: #856404;">
                        <strong>üîß Setup Instructions:</strong><br>
                        1. Go to <a href="https://developer.spotify.com/dashboard" target="_blank" style="color: #1db954; text-decoration: none;">Spotify Developer Dashboard</a><br>
                        2. Create a new app or select existing one<br>
                        3. Copy your Client ID below<br>
                        4. In app settings, add redirect URI: <code id="currentRedirectUri" style="background: #f8f9fa; padding: 2px 4px; border-radius: 3px; user-select: all; cursor: text;"></code><br>
                        5. Click "Connect to Spotify" below
                    </div>
                    
                    <div class="form-group">
                        <label for="spotifyClientId">Spotify Client ID:</label>
                        <input type="text" id="spotifyClientId" placeholder="Paste your Spotify App Client ID here" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;" onchange="saveSettings();">
                        <small style="color: #666; margin-top: 5px; display: block;">Get this from your Spotify app in the Developer Dashboard</small>
                    </div>
                    
                    <button type="button" onclick="authorizeSpotify()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #1db954, #1ed760); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 600; margin-bottom: 10px;">üîë Connect to Spotify</button>
                    
                    <button type="button" onclick="testSpotifyConnection()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #a29bfe, #6c5ce7); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 600; margin-bottom: 10px;">üîó Test Connection</button>
                    
                    <div id="spotifyStatus" style="padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 12px; color: #666; text-align: center;">
                        Not connected
                    </div>
                    
                    <div style="margin-top: 15px; padding: 12px; background: #e8f5e8; border: 2px solid #27ae60; border-radius: 10px; font-size: 12px; color: #2d3436;">
                        <strong>üéµ Voice Commands:</strong><br>
                        ‚Ä¢ "play music" - Start/resume playback<br>
                        ‚Ä¢ "pause music" - Pause playback<br>
                        ‚Ä¢ "skip" / "next song" - Skip to next track<br>
                        ‚Ä¢ "previous" / "last song" - Go to previous track<br>
                        ‚Ä¢ "play [song/artist]" - Search and play specific music<br>
                        ‚Ä¢ "volume to [number]" - Set volume (0-100)<br>
                        ‚Ä¢ "turn up" / "turn down" - Adjust volume<br>
                        ‚Ä¢ "what's playing" - Get current track info
                    </div>
                </div>
            </div>
            
            <div class="settings">
                <h3>üëã Absence Greeting</h3>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="useAbsenceGreeting" onchange="saveSettings();" style="transform: scale(1.2);">
                        <strong>Enable Absence Welcome</strong>
                    </label>
                    <small style="color: #666; margin-top: 5px; display: block;">Greet with time-appropriate message when returning after being away</small>
                </div>
                
                <div class="form-group">
                    <label for="absenceMinutes">Absence Duration (minutes):</label>
                    <input type="number" id="absenceMinutes" min="5" max="1440" value="30" onchange="saveSettings();" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;">
                    <small style="color: #666; margin-top: 5px; display: block;">How long you must be away before getting a welcome back greeting</small>
                </div>
                
                <div class="form-group">
                    <label for="morningGreeting">Morning Greeting (6:00 - 11:59):</label>
                    <input type="text" id="morningGreeting" placeholder="Good morning sir, welcome back" value="Good morning sir, welcome back" onchange="saveSettings();" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;">
                </div>
                
                <div class="form-group">
                    <label for="afternoonGreeting">Afternoon Greeting (12:00 - 17:59):</label>
                    <input type="text" id="afternoonGreeting" placeholder="Good afternoon sir, welcome back" value="Good afternoon sir, welcome back" onchange="saveSettings();" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;">
                </div>
                
                <div class="form-group">
                    <label for="eveningGreeting">Evening Greeting (18:00 - 21:59):</label>
                    <input type="text" id="eveningGreeting" placeholder="Good evening sir, welcome back" value="Good evening sir, welcome back" onchange="saveSettings();" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;">
                </div>
                
                <div class="form-group">
                    <label for="nightGreeting">Night Greeting (22:00 - 05:59):</label>
                    <input type="text" id="nightGreeting" placeholder="Good evening sir, welcome back" value="Good evening sir, welcome back" onchange="saveSettings();" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;">
                </div>
                
                <div class="form-group">
                    <label for="greetingCustomMessage">Custom Message (added after greeting):</label>
                    <textarea id="greetingCustomMessage" placeholder="I trust you've had a great day" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 60px; resize: vertical;" onchange="saveSettings();">I trust you've had a great day</textarea>
                    <small style="color: #666; margin-top: 5px; display: block;">Additional message to append after the time-based greeting</small>
                </div>
                
                <div class="form-group">
                    <label for="normalWakeResponses">Normal Wake Responses (comma-separated):</label>
                    <textarea id="normalWakeResponses" placeholder="Yes sir, Yes, Ready, Listening, Here, Go ahead" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 60px; resize: vertical;" onchange="saveSettings();">Yes sir, Yes, Ready, Listening, Here, Go ahead</textarea>
                    <small style="color: #666; margin-top: 5px; display: block;">Random responses when waking up without an absence greeting</small>
                </div>
                
                <div class="form-group">
                    <button type="button" onclick="updateNormalWakeResponses()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #a29bfe, #6c5ce7); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 600; margin-bottom: 10px;">üîÑ Update Normal Wake Responses</button>
                    
                    <button type="button" onclick="resetNormalWakeResponses()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #ffeaa7, #fdcb6e); color: #2d3436; border: none; border-radius: 10px; cursor: pointer; font-size: 12px; font-weight: 600;">‚Ü©Ô∏è Reset to Defaults</button>
                </div>
                
                <div class="form-group">
                    <label for="sleepResponses">Sleep Responses (comma-separated):</label>
                    <textarea id="sleepResponses" placeholder="Going to sleep, Sleep mode, Resting now, Standby, Good night, Sleeping" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 60px; resize: vertical;" onchange="saveSettings();">Going to sleep, Sleep mode, Resting now, Standby, Good night, Sleeping</textarea>
                    <small style="color: #666; margin-top: 5px; display: block;">Random responses when going to sleep</small>
                </div>
                
                <div class="form-group">
                    <button type="button" onclick="updateSleepResponses()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #a29bfe, #6c5ce7); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 600; margin-bottom: 10px;">üîÑ Update Sleep Responses</button>
                    
                    <button type="button" onclick="resetSleepResponses()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #ffeaa7, #fdcb6e); color: #2d3436; border: none; border-radius: 10px; cursor: pointer; font-size: 12px; font-weight: 600;">‚Ü©Ô∏è Reset to Defaults</button>
                </div>
                
                <div class="form-group">
                    <label for="openSettingsPhrase">Voice Settings Phrase:</label>
                    <input type="text" id="openSettingsPhrase" placeholder="open settings" value="open settings" onchange="saveSettings();" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;">
                    <small style="color: #666; margin-top: 5px; display: block;">Say this phrase to open settings panel via voice command</small>
                </div>
                
                <div class="form-group">
                    <label for="settingsPassword">Settings Lock Password:</label>
                    <input type="password" id="settingsPassword" placeholder="password" value="password" onchange="saveSettings();" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;">
                    <small style="color: #666; margin-top: 5px; display: block;">Password required for the lock button in fullscreen mode</small>
                </div>
            </div>
            
            <div class="settings">
                <h3>‚è∞ Smart Reminders</h3>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="useReminders" onchange="saveSettings();" style="transform: scale(1.2);">
                        <strong>Enable Smart Reminders</strong>
                    </label>
                    <small style="color: #666; margin-top: 5px; display: block;">Allow the bot to set and manage voice reminders</small>
                </div>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="requireReminderConfirmation" onchange="saveSettings();" style="transform: scale(1.2);">
                        <strong>Require Confirmation</strong>
                    </label>
                    <small style="color: #666; margin-top: 5px; display: block;">Ask for confirmation before setting reminders</small>
                </div>
                
                <div class="form-group">
                    <label for="maxReminders">Maximum Active Reminders:</label>
                    <select id="maxReminders" onchange="saveSettings();" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;">
                        <option value="10">10 reminders</option>
                        <option value="25">25 reminders</option>
                        <option value="50">50 reminders</option>
                        <option value="100">100 reminders</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="reminderSnooze">Default Snooze Time (minutes):</label>
                    <input type="number" id="reminderSnooze" min="1" max="60" value="5" onchange="saveSettings();" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;">
                    <small style="color: #666; margin-top: 5px; display: block;">How long to snooze reminders when dismissed</small>
                </div>
                
                <div class="form-group">
                    <label for="missedReminderMessage">Missed Reminder Message:</label>
                    <input type="text" id="missedReminderMessage" placeholder="You told me to remind you of '{reminder}' at {time}" onchange="saveSettings();" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box;">
                    <small style="color: #666; margin-top: 5px; display: block;">Message for reminders that were missed while app was closed. Use {reminder} and {time} as placeholders.</small>
                </div>
                
                <div class="form-group">
                    <button type="button" onclick="listActiveReminders()" style="width: 48%; padding: 10px; background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: 600; margin-right: 4%;">üìã List Reminders</button>
                    <button type="button" onclick="clearAllReminders()" style="width: 48%; padding: 10px; background: linear-gradient(135deg, #fd79a8, #e84393); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: 600;">üóëÔ∏è Clear All</button>
                </div>
                
                <div id="activeRemindersList" style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 10px; font-size: 12px; color: #666; max-height: 150px; overflow-y: auto; display: none;">
                    <strong>Active Reminders:</strong>
                    <div id="reminderItems"></div>
                </div>
            </div>
            
            <div class="settings">
                <h3>ÔøΩ Fallback Responses</h3>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="useFallbackResponses" onchange="saveSettings();" style="transform: scale(1.2);">
                        <strong>Use Custom Fallback Responses</strong>
                    </label>
                    <small style="color: #666; margin-top: 5px; display: block;">Enable custom responses when bot doesn't hear or understand you</small>
                </div>
                
                <div class="form-group">
                    <label for="noSpeechInput">No Speech Detected Responses (comma-separated):</label>
                    <textarea id="noSpeechInput" placeholder="I didn't hear anything. Could you try again?, I'm not hearing you clearly. Please speak up., Sorry I didn't catch that. Can you repeat?" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 60px; resize: vertical;"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="didntUnderstandInput">Didn't Understand Responses (comma-separated):</label>
                    <textarea id="didntUnderstandInput" placeholder="I didn't understand that command., That's not a command I recognize., I'm not sure what you mean., Can you try a different command?" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 60px; resize: vertical;"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="speechErrorInput">Speech Recognition Error Responses (comma-separated):</label>
                    <textarea id="speechErrorInput" placeholder="Sorry I'm having trouble understanding you right now., There seems to be an issue with speech recognition., I'm experiencing some difficulties hearing you." style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 14px; box-sizing: border-box; min-height: 60px; resize: vertical;"></textarea>
                </div>
                
                <button type="button" onclick="updateFallbackResponses()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #a29bfe, #6c5ce7); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 600; margin-bottom: 10px;">üîÑ Update Fallback Responses</button>
                
                <button type="button" onclick="resetFallbackResponses()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #ffeaa7, #fdcb6e); color: #2d3436; border: none; border-radius: 10px; cursor: pointer; font-size: 12px; font-weight: 600;">‚Ü©Ô∏è Reset to Defaults</button>
            </div>
            
            <div class="settings">
                <h3>ÔøΩüíæ Settings Management</h3>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <button type="button" onclick="exportSettings()" style="padding: 12px; background: linear-gradient(135deg, #00b894, #00cec9); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 12px; font-weight: 600;">üì§ Export Settings</button>
                    <button type="button" onclick="importSettings()" style="padding: 12px; background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 12px; font-weight: 600;">üì• Import Settings</button>
                </div>
                
                <button type="button" onclick="resetAllSettings()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #fd79a8, #e84393); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 12px; font-weight: 600;">üîÑ Reset All Settings</button>
                
                <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 10px; font-size: 11px; color: #666;">
                    <strong>üí° Auto-Save:</strong> All settings are automatically saved to your browser's local storage and will be restored when you reload the page.
                </div>
            </div>
        </div>
    </div>

    <script>
        let speechRecognition;
        let isListening = false;
        let isBotActive = false;
        let isAwake = false;
        let currentUtterance = null;
        let conversationCount = 0;
        let responseCount = 0;
        let awakeTimeout;
        let availableMicrophones = [];
        let selectedMicrophoneId = null;
        let isSpeaking = false;
        let audioContext = null;
        let microphoneStream = null;
        let speechTimeout = null;
        let lastBotResponse = '';
        let botSpeechStartTime = 0;
        let botSpeechEndTime = 0;
        let lastSpokenText = '';
        let cameraStream = null;
        let isCameraActive = false;
        let detectionModel = null;
        let isModelLoading = false;
        let motionDetectionActive = false;
        let motionDetectionInterval = null;
        let previousFrame = null;
        let motionCanvas = null;
        
        // Mobile detection and optimization
        let isMobileDevice = detectMobileDevice();
        let lastMicrophoneActivity = 0;
        let silenceTimeout = null;
        let restartTimeout = null;
        let voiceActivityDetector = null;
        let mobileOptimizationEnabled = true;
        
        // Detect mobile device
        function detectMobileDevice() {
            const userAgent = navigator.userAgent.toLowerCase();
            const mobileKeywords = ['android', 'iphone', 'ipad', 'ipod', 'blackberry', 'windows phone', 'opera mini'];
            const isMobile = mobileKeywords.some(keyword => userAgent.includes(keyword));
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const hasSmallScreen = window.innerWidth <= 768;
            
            return isMobile || (isTouchDevice && hasSmallScreen);
        }
        
        // Voice Activity Detection for mobile optimization
        function initVoiceActivityDetection() {
            if (!audioContext || !microphoneStream) return null;
            
            const analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(microphoneStream);
            source.connect(analyser);
            
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            let silenceStart = Date.now();
            const SILENCE_THRESHOLD = 50; // Adjust as needed
            const SILENCE_DURATION = 3000; // 3 seconds of silence
            
            function checkAudioLevel() {
                if (!isBotActive || isSpeaking) return;
                
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((acc, val) => acc + val, 0) / bufferLength;
                
                if (average > SILENCE_THRESHOLD) {
                    lastMicrophoneActivity = Date.now();
                    silenceStart = Date.now();
                } else if (Date.now() - silenceStart > SILENCE_DURATION && isMobileDevice) {
                    // Stop listening after prolonged silence on mobile
                    console.log('Prolonged silence detected on mobile, stopping speech recognition');
                    if (speechRecognition && isListening) {
                        speechRecognition.stop();
                    }
                }
                
                if (isBotActive) {
                    requestAnimationFrame(checkAudioLevel);
                }
            }
            
            checkAudioLevel();
            return { analyser, source };
        }
        let motionContext = null;
        let lastInteractionTime = null;
        let absenceGreetingGiven = false;
        
        // Spotify integration variables
        let spotifyAccessToken = null;
        let spotifyRefreshToken = null;
        let spotifyDeviceId = null;
        let spotifyPlayer = null;
        
        // Reminder system variables
        let activeReminders = [];
        let reminderIdCounter = 1;
        let reminderState = 'none'; // 'none', 'listening', 'confirming', 'timing'
        let pendingReminder = null;
        let reminderTimers = new Map();
        
        // Fallback response arrays
        let noSpeechResponses = [];
        let didntUnderstandResponses = [];
        let speechErrorResponses = [];
        
        // Normal wake response array
        let normalWakeResponses = ['Yes sir', 'Yes', 'Ready', 'Listening', 'Here', 'Go ahead'];
        
        // Sleep response array
        let sleepResponses = ['Going to sleep', 'Sleep mode', 'Resting now', 'Standby', 'Good night', 'Sleeping'];
        
        // Intro Video Functions
        function initIntroVideo() {
            const introVideo = document.getElementById('introVideo');
            const introOverlay = document.getElementById('introOverlay');
            const unmuteBtn = document.getElementById('introUnmute');
            
            if (introVideo && introOverlay) {
                // Start muted for autoplay compatibility
                introVideo.muted = true;
                
                // Set video source to the file
                introVideo.src = 'intro.mp4';
                
                // Handle video loaded and ready to play
                introVideo.addEventListener('loadeddata', () => {
                    console.log('Intro video loaded successfully');
                });
                
                // Handle video end
                introVideo.addEventListener('ended', () => {
                    console.log('Intro video ended');
                    hideIntroVideo();
                });
                
                // Handle video error
                introVideo.addEventListener('error', (e) => {
                    console.log('Intro video failed to load, skipping intro');
                    hideIntroVideo();
                });
                
                // Handle video cannot play
                introVideo.addEventListener('cannotplay', (e) => {
                    console.log('Intro video cannot play, skipping intro');
                    hideIntroVideo();
                });
                
                // Hide intro after 15 seconds as failsafe (in case video is longer)
                setTimeout(() => {
                    if (introOverlay && !introOverlay.classList.contains('fade-out')) {
                        console.log('Intro video timeout reached, hiding overlay');
                        hideIntroVideo();
                    }
                }, 15000);
                
                // Try to play the video
                const playPromise = introVideo.play();
                if (playPromise) {
                    playPromise.then(() => {
                        console.log('Intro video playing (muted)');
                        // Try to unmute after a short delay for better browser compatibility
                        setTimeout(() => {
                            tryUnmuteVideo();
                        }, 500);
                    }).catch(error => {
                        console.log('Auto-play failed, video will need user interaction');
                        showPlayPrompt();
                    });
                }
            }
        }
        
        function showPlayPrompt() {
            const playPrompt = document.getElementById('introPlayPrompt');
            const introOverlay = document.getElementById('introOverlay');
            
            if (playPrompt && introOverlay) {
                playPrompt.style.display = 'block';
                
                // Add click handler to start video
                introOverlay.addEventListener('click', () => {
                    const introVideo = document.getElementById('introVideo');
                    if (introVideo) {
                        introVideo.play().then(() => {
                            playPrompt.style.display = 'none';
                            setTimeout(() => {
                                tryUnmuteVideo();
                            }, 500);
                        }).catch(e => console.log('Manual play failed:', e));
                    }
                });
            }
        }
        
        function tryUnmuteVideo() {
            const introVideo = document.getElementById('introVideo');
            const unmuteBtn = document.getElementById('introUnmute');
            
            if (introVideo && unmuteBtn) {
                // Try to unmute automatically
                introVideo.muted = false;
                
                // Check if unmuting worked (some browsers block this)
                setTimeout(() => {
                    if (introVideo.muted) {
                        console.log('Automatic unmute failed, showing unmute button');
                        unmuteBtn.style.display = 'block';
                        unmuteBtn.textContent = 'üîä Click for Sound';
                    } else {
                        console.log('Video unmuted successfully');
                        unmuteBtn.style.display = 'none';
                    }
                }, 100);
            }
        }
        
        function toggleIntroSound() {
            const introVideo = document.getElementById('introVideo');
            const unmuteBtn = document.getElementById('introUnmute');
            
            if (introVideo && unmuteBtn) {
                if (introVideo.muted) {
                    introVideo.muted = false;
                    unmuteBtn.textContent = 'üîá Mute';
                    unmuteBtn.classList.add('sound-enabled');
                    console.log('Intro video unmuted by user');
                } else {
                    introVideo.muted = true;
                    unmuteBtn.textContent = 'üîä Enable Sound';
                    unmuteBtn.classList.remove('sound-enabled');
                    console.log('Intro video muted by user');
                }
            }
        }
        
        function hideIntroVideo() {
            const introOverlay = document.getElementById('introOverlay');
            const introVideo = document.getElementById('introVideo');
            
            if (introOverlay) {
                console.log('Hiding intro video overlay');
                introOverlay.classList.add('fade-out');
                
                // Pause video
                if (introVideo) {
                    introVideo.pause();
                }
                
                setTimeout(() => {
                    introOverlay.style.display = 'none';
                    console.log('Intro video overlay hidden');
                }, 500);
            }
        }
        
        function skipIntro() {
            console.log('Skip intro button clicked');
            hideIntroVideo();
        }
        
        // Reminder System Functions
        function parseTimeInput(input) {
            const lowerInput = input.toLowerCase().trim();
            let minutes = 0;
            
            // Handle various time formats
            const timeRegex = /in\s+(\d+)\s*(minute|minutes|hour|hours|day|days)/i;
            const match = lowerInput.match(timeRegex);
            
            if (match) {
                const amount = parseInt(match[1]);
                const unit = match[2].toLowerCase();
                
                switch (unit) {
                    case 'minute':
                    case 'minutes':
                        minutes = amount;
                        break;
                    case 'hour':
                    case 'hours':
                        minutes = amount * 60;
                        break;
                    case 'day':
                    case 'days':
                        minutes = amount * 60 * 24;
                        break;
                }
                
                return minutes > 0 ? minutes : null;
            }
            
            // Handle "in a minute", "in an hour", "in a day"
            if (lowerInput.includes('in a minute') || lowerInput.includes('in one minute')) {
                return 1;
            }
            if (lowerInput.includes('in an hour') || lowerInput.includes('in one hour')) {
                return 60;
            }
            if (lowerInput.includes('in a day') || lowerInput.includes('in one day')) {
                return 60 * 24;
            }
            
            return null;
        }
        
        function formatTimeUntil(minutes) {
            if (minutes < 60) {
                return `${minutes} minute${minutes !== 1 ? 's' : ''}`;
            } else if (minutes < 1440) {
                const hours = Math.floor(minutes / 60);
                const remainingMinutes = minutes % 60;
                let result = `${hours} hour${hours !== 1 ? 's' : ''}`;
                if (remainingMinutes > 0) {
                    result += ` and ${remainingMinutes} minute${remainingMinutes !== 1 ? 's' : ''}`;
                }
                return result;
            } else {
                const days = Math.floor(minutes / 1440);
                const remainingHours = Math.floor((minutes % 1440) / 60);
                let result = `${days} day${days !== 1 ? 's' : ''}`;
                if (remainingHours > 0) {
                    result += ` and ${remainingHours} hour${remainingHours !== 1 ? 's' : ''}`;
                }
                return result;
            }
        }
        
        function createReminder(text, minutes) {
            const useReminders = document.getElementById('useReminders').checked;
            const maxReminders = parseInt(document.getElementById('maxReminders').value);
            
            if (!useReminders) {
                return "Reminders are currently disabled in settings.";
            }
            
            if (activeReminders.length >= maxReminders) {
                return "You have too many active reminders. Please cancel some first.";
            }
            
            const now = new Date();
            const reminderTime = new Date(now.getTime() + minutes * 60000);
            
            const reminder = {
                id: reminderIdCounter++,
                text: text,
                scheduledTime: reminderTime,
                createdTime: now,
                minutes: minutes
            };
            
            activeReminders.push(reminder);
            
            // Set the timer
            const timerId = setTimeout(() => {
                triggerReminder(reminder.id);
            }, minutes * 60000);
            
            reminderTimers.set(reminder.id, timerId);
            
            // Save to localStorage
            saveRemindersToStorage();
            updateRemindersList();
            
            return `Reminder set for ${formatTimeUntil(minutes)} from now. I'll notify you then.`;
        }
        
        function triggerReminder(reminderId) {
            const reminder = activeReminders.find(r => r.id === reminderId);
            if (!reminder) return;
            
            // Remove from active reminders
            activeReminders = activeReminders.filter(r => r.id !== reminderId);
            reminderTimers.delete(reminderId);
            
            // Trigger the reminder notification
            const message = `Reminder: ${reminder.text}`;
            addMessage('bot', message);
            respondToUser(message);
            
            // Update display
            saveRemindersToStorage();
            updateRemindersList();
            
            console.log('Reminder triggered:', reminder.text);
        }
        
        function handleReminderInput(input) {
            const useReminders = document.getElementById('useReminders').checked;
            if (!useReminders) return false;
            
            const lowerInput = input.toLowerCase().trim();
            
            // Check if this is a reminder request
            if (lowerInput.includes('remind me')) {
                reminderState = 'listening';
                respondToUser("Listening for your reminder...");
                return true;
            }
            
            // Handle states
            if (reminderState === 'listening') {
                // Store the reminder text
                pendingReminder = {
                    text: input,
                    original: input
                };
                
                const requireConfirmation = document.getElementById('requireReminderConfirmation').checked;
                
                if (requireConfirmation) {
                    reminderState = 'confirming';
                    respondToUser(`You want me to remind you: "${input}". Is that correct?`);
                } else {
                    reminderState = 'timing';
                    respondToUser("When should I remind you?");
                }
                return true;
            }
            
            if (reminderState === 'confirming') {
                if (lowerInput.includes('yes') || lowerInput.includes('correct') || lowerInput.includes('right')) {
                    reminderState = 'timing';
                    respondToUser("When should I remind you?");
                    return true;
                } else if (lowerInput.includes('no') || lowerInput.includes('wrong') || lowerInput.includes('incorrect')) {
                    reminderState = 'listening';
                    respondToUser("Let me listen again for your reminder...");
                    return true;
                }
            }
            
            if (reminderState === 'timing') {
                const minutes = parseTimeInput(input);
                if (minutes) {
                    const result = createReminder(pendingReminder.text, minutes);
                    respondToUser(result);
                    reminderState = 'none';
                    pendingReminder = null;
                    return true;
                } else {
                    respondToUser("I didn't understand that time format. Please say something like 'in 30 minutes', 'in 2 hours', or 'in 1 day'.");
                    return true;
                }
            }
            
            return false;
        }
        
        function saveRemindersToStorage() {
            try {
                const reminderData = {
                    reminders: activeReminders,
                    counter: reminderIdCounter
                };
                localStorage.setItem('voiceBotReminders', JSON.stringify(reminderData));
            } catch (error) {
                console.error('Error saving reminders:', error);
            }
        }
        
        function loadRemindersFromStorage() {
            try {
                const saved = localStorage.getItem('voiceBotReminders');
                if (saved) {
                    const data = JSON.parse(saved);
                    reminderIdCounter = data.counter || 1;
                    
                    // Restore active reminders and set up timers
                    data.reminders.forEach(reminder => {
                        reminder.scheduledTime = new Date(reminder.scheduledTime);
                        reminder.createdTime = new Date(reminder.createdTime);
                        
                        const now = new Date();
                        const timeLeft = reminder.scheduledTime.getTime() - now.getTime();
                        
                        if (timeLeft > 0) {
                            activeReminders.push(reminder);
                            
                            // Set timer for remaining time
                            const timerId = setTimeout(() => {
                                triggerReminder(reminder.id);
                            }, timeLeft);
                            
                            reminderTimers.set(reminder.id, timerId);
                        }
                    });
                    
                    updateRemindersList();
                }
            } catch (error) {
                console.error('Error loading reminders:', error);
            }
        }
        
        function listActiveReminders() {
            updateRemindersList();
            const remindersList = document.getElementById('activeRemindersList');
            if (remindersList) {
                remindersList.style.display = activeReminders.length > 0 ? 'block' : 'none';
            }
            
            if (activeReminders.length === 0) {
                respondToUser("You have no active reminders.");
            } else {
                respondToUser(`You have ${activeReminders.length} active reminder${activeReminders.length !== 1 ? 's' : ''}.`);
            }
        }
        
        function updateRemindersList() {
            const reminderItems = document.getElementById('reminderItems');
            if (!reminderItems) return;
            
            if (activeReminders.length === 0) {
                reminderItems.innerHTML = '<div style="color: #999; font-style: italic; margin-top: 5px;">No active reminders</div>';
                return;
            }
            
            reminderItems.innerHTML = '';
            
            activeReminders.forEach(reminder => {
                const div = document.createElement('div');
                div.style.marginTop = '8px';
                div.style.padding = '8px';
                div.style.background = '#fff';
                div.style.borderRadius = '5px';
                div.style.border = '1px solid #ddd';
                div.id = `reminder-${reminder.id}`;
                
                div.innerHTML = `
                    <strong>${reminder.text}</strong>
                    <br>
                    <small class="countdown" data-time="${new Date(reminder.scheduledTime).getTime()}">Calculating...</small>
                    <button onclick="editReminder(${reminder.id})" style="float: right; background: #3498db; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px; margin-left: 4px;">‚úèÔ∏è</button>
                    <button onclick="cancelReminder(${reminder.id})" style="float: right; background: #e74c3c; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px;">‚úï</button>
                `;
                
                reminderItems.appendChild(div);
            });
            
            updateCountdowns();
        }
        
        // Update countdown displays in real-time
        function updateCountdowns() {
            const countdownElements = document.querySelectorAll('.countdown');
            const now = new Date().getTime();
            
            countdownElements.forEach(element => {
                const targetTime = parseInt(element.getAttribute('data-time'));
                const timeLeft = targetTime - now;
                
                if (timeLeft <= 0) {
                    element.textContent = 'Time reached!';
                    element.style.color = '#e74c3c';
                } else {
                    const seconds = Math.floor(timeLeft / 1000);
                    const minutes = Math.floor(seconds / 60);
                    const hours = Math.floor(minutes / 60);
                    const days = Math.floor(hours / 24);
                    
                    let timeText = '';
                    if (days > 0) {
                        timeText = `${days}d ${hours % 24}h ${minutes % 60}m`;
                    } else if (hours > 0) {
                        timeText = `${hours}h ${minutes % 60}m ${seconds % 60}s`;
                    } else if (minutes > 0) {
                        timeText = `${minutes}m ${seconds % 60}s`;
                    } else {
                        timeText = `${seconds}s`;
                    }
                    
                    element.textContent = `In ${timeText}`;
                    element.style.color = timeLeft < 300000 ? '#e67e22' : '#666'; // Orange if less than 5 minutes
                }
            });
        }
        
        function cancelReminder(reminderId) {
            const timer = reminderTimers.get(reminderId);
            if (timer) {
                clearTimeout(timer);
                reminderTimers.delete(reminderId);
            }
            
            activeReminders = activeReminders.filter(r => r.id !== reminderId);
            saveRemindersToStorage();
            updateRemindersList();
            
            respondToUser("Reminder cancelled.");
        }
        
        function editReminder(reminderId) {
            const reminder = activeReminders.find(r => r.id === reminderId);
            if (!reminder) {
                respondToUser("Reminder not found.");
                return;
            }
            
            const newText = prompt(`Edit reminder text:`, reminder.text);
            if (newText === null || newText.trim() === '') {
                return; // User cancelled or entered empty text
            }
            
            const currentTime = new Date(reminder.scheduledTime);
            const timeString = currentTime.toLocaleString();
            const newTimeString = prompt(`Edit reminder time (current: ${timeString}):`, timeString);
            if (newTimeString === null) {
                return; // User cancelled
            }
            
            let newTime;
            try {
                newTime = new Date(newTimeString);
                if (isNaN(newTime.getTime())) {
                    throw new Error('Invalid date');
                }
            } catch (e) {
                alert('Invalid time format. Please use a valid date/time format.');
                return;
            }
            
            if (newTime <= new Date()) {
                alert('Please set a time in the future.');
                return;
            }
            
            // Cancel old timer
            const timer = reminderTimers.get(reminderId);
            if (timer) {
                clearTimeout(timer);
                reminderTimers.delete(reminderId);
            }
            
            // Update reminder
            reminder.text = newText.trim();
            reminder.scheduledTime = newTime.getTime();
            
            // Set new timer
            const timeUntilReminder = newTime.getTime() - Date.now();
            const newTimer = setTimeout(() => {
                triggerReminder(reminderId);
            }, timeUntilReminder);
            
            reminderTimers.set(reminderId, newTimer);
            
            saveRemindersToStorage();
            updateRemindersList();
            
            respondToUser(`Reminder updated: "${newText}" at ${newTime.toLocaleString()}`);
        }
        
        function clearAllReminders() {
            if (activeReminders.length === 0) {
                respondToUser("You have no active reminders to clear.");
                return;
            }
            
            if (confirm(`Are you sure you want to cancel all ${activeReminders.length} active reminders?`)) {
                // Clear all timers
                reminderTimers.forEach(timer => clearTimeout(timer));
                reminderTimers.clear();
                
                // Clear reminders
                activeReminders = [];
                reminderState = 'none';
                pendingReminder = null;
                
                saveRemindersToStorage();
                updateRemindersList();
                
                const remindersList = document.getElementById('activeRemindersList');
                if (remindersList) {
                    remindersList.style.display = 'none';
                }
                
                respondToUser("All reminders cleared.");
            }
        }
        
        // Check for reminders that should have triggered while app was closed
        function checkForMissedReminders() {
            const missedReminders = [];
            const now = new Date().getTime();
            
            // Check active reminders for any that should have triggered
            for (let i = activeReminders.length - 1; i >= 0; i--) {
                const reminder = activeReminders[i];
                if (reminder.scheduledTime && new Date(reminder.scheduledTime).getTime() <= now) {
                    // This reminder should have triggered
                    missedReminders.push(reminder);
                    // Remove from active reminders
                    activeReminders.splice(i, 1);
                }
            }
            
            // Save updated reminders to localStorage
            if (missedReminders.length > 0) {
                saveRemindersToStorage();
                updateRemindersList();
            }
            
            return missedReminders;
        }
        
        // Announce missed reminders to the user
        function announceMissedReminders(missedReminders) {
            const missedReminderTemplate = document.getElementById('missedReminderMessage').value || defaultSettings.missedReminderMessage;
            
            for (const reminder of missedReminders) {
                const reminderTime = new Date(reminder.scheduledTime).toLocaleString([], {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit', 
                    minute: '2-digit'
                });
                let message = missedReminderTemplate
                    .replace('{reminder}', reminder.text)
                    .replace('{time}', reminderTime);
                
                addMessage('assistant', message);
                speak(message);
            }
            
            // Update the reminders display
            updateRemindersList();
        }

        // Fallback Response Functions
        function getRandomFallbackResponse(responseType) {
            const useFallbackResponses = document.getElementById('useFallbackResponses').checked;
            if (!useFallbackResponses) {
                // Use default responses if custom fallbacks are disabled
                return getDefaultFallbackResponse(responseType);
            }
            
            let responses = [];
            
            switch (responseType) {
                case 'noSpeech':
                    responses = noSpeechResponses.length > 0 ? noSpeechResponses : defaultSettings.noSpeechResponses;
                    break;
                case 'didntUnderstand':
                    responses = didntUnderstandResponses.length > 0 ? didntUnderstandResponses : defaultSettings.didntUnderstandResponses;
                    break;
                case 'speechError':
                    responses = speechErrorResponses.length > 0 ? speechErrorResponses : defaultSettings.speechErrorResponses;
                    break;
                default:
                    return getDefaultFallbackResponse(responseType);
            }
            
            if (responses.length === 0) {
                return getDefaultFallbackResponse(responseType);
            }
            
            return responses[Math.floor(Math.random() * responses.length)];
        }
        
        function getDefaultFallbackResponse(responseType) {
            switch (responseType) {
                case 'noSpeech':
                    return "I didn't hear anything. Could you try again?";
                case 'didntUnderstand':
                    return "I didn't understand that command. You can add custom commands in the settings.";
                case 'speechError':
                    return "Sorry, I'm having trouble understanding you right now.";
                default:
                    return "I'm not sure how to respond to that.";
            }
        }
        
        function updateFallbackResponses() {
            const noSpeechText = document.getElementById('noSpeechInput').value.trim();
            const didntUnderstandText = document.getElementById('didntUnderstandInput').value.trim();
            const speechErrorText = document.getElementById('speechErrorInput').value.trim();
            
            if (noSpeechText) {
                noSpeechResponses = noSpeechText.split(',').map(response => response.trim()).filter(response => response.length > 0);
            }
            if (didntUnderstandText) {
                didntUnderstandResponses = didntUnderstandText.split(',').map(response => response.trim()).filter(response => response.length > 0);
            }
            if (speechErrorText) {
                speechErrorResponses = speechErrorText.split(',').map(response => response.trim()).filter(response => response.length > 0);
            }
            
            saveSettings();
            alert('Fallback responses updated successfully!');
        }
        
        function updateNormalWakeResponses() {
            const normalWakeText = document.getElementById('normalWakeResponses').value.trim();
            
            if (normalWakeText) {
                normalWakeResponses = normalWakeText.split(',').map(response => response.trim()).filter(response => response.length > 0);
                saveSettings();
                alert('Normal wake responses updated successfully!');
            } else {
                alert('Please enter at least one wake response.');
            }
        }
        
        function resetNormalWakeResponses() {
            if (confirm('Reset normal wake responses to defaults?')) {
                document.getElementById('normalWakeResponses').value = defaultSettings.normalWakeResponses.join(', ');
                normalWakeResponses = [...defaultSettings.normalWakeResponses];
                saveSettings();
                alert('Normal wake responses reset to defaults.');
            }
        }
        
        function updateSleepResponses() {
            const sleepText = document.getElementById('sleepResponses').value.trim();
            
            if (sleepText) {
                sleepResponses = sleepText.split(',').map(response => response.trim()).filter(response => response.length > 0);
                saveSettings();
                alert('Sleep responses updated successfully!');
            } else {
                alert('Please enter at least one sleep response.');
            }
        }
        
        function resetSleepResponses() {
            if (confirm('Reset sleep responses to defaults?')) {
                document.getElementById('sleepResponses').value = defaultSettings.sleepResponses.join(', ');
                sleepResponses = [...defaultSettings.sleepResponses];
                saveSettings();
                alert('Sleep responses reset to defaults.');
            }
        }
        
        function resetFallbackResponses() {
            if (confirm('Reset fallback responses to defaults?')) {
                document.getElementById('noSpeechInput').value = defaultSettings.noSpeechResponses.join(', ');
                document.getElementById('didntUnderstandInput').value = defaultSettings.didntUnderstandResponses.join(', ');
                document.getElementById('speechErrorInput').value = defaultSettings.speechErrorResponses.join(', ');
                
                noSpeechResponses = [...defaultSettings.noSpeechResponses];
                didntUnderstandResponses = [...defaultSettings.didntUnderstandResponses];
                speechErrorResponses = [...defaultSettings.speechErrorResponses];
                
                saveSettings();
                alert('Fallback responses reset to defaults.');
            }
        }
        
        // Settings configuration object
        const defaultSettings = {
            voice: 'en-US-AriaNeural',
            language: 'en-US',
            speed: 'medium',
            pitch: '1.0',
            timeout: '2000',
            wakeWords: ['hey bot', 'hello bot', 'assistant', 'computer'],
            sleepWords: ['sleep', 'go to sleep', 'sleep mode', 'rest', 'standby'],
            interruptWords: ['stop', 'stop speaking', 'be quiet', 'shut up', 'halt', 'interrupt', 'pause', 'cancel'],
            useOllama: false,
            ollamaModel: 'tinyllama',
            ollamaUrl: 'http://localhost:11434',
            useSpotify: false,
            spotifyClientId: '',
            useAbsenceGreeting: true,
            absenceMinutes: 30,
            morningGreeting: 'Good morning sir, welcome back',
            afternoonGreeting: 'Good afternoon sir, welcome back',
            eveningGreeting: 'Good evening sir, welcome back',
            nightGreeting: 'Good evening sir, welcome back',
            greetingCustomMessage: 'I trust you\'ve had a great day',
            normalWakeResponses: ['Yes sir', 'Yes', 'Ready', 'Listening', 'Here', 'Go ahead'],
            sleepResponses: ['Going to sleep', 'Sleep mode', 'Resting now', 'Standby', 'Good night', 'Sleeping'],
            openSettingsPhrase: 'open settings',
            settingsPassword: 'password',
            useReminders: true,
            requireReminderConfirmation: true,
            maxReminders: 50,
            reminderSnooze: 5,
            missedReminderMessage: "You told me to remind you of '{reminder}' at {time}",
            useFallbackResponses: true,
            noSpeechResponses: [
                "I didn't hear anything. Could you try again?",
                "I'm not hearing you clearly. Please speak up.",
                "Sorry, I didn't catch that. Can you repeat?",
                "I'm listening, but I don't hear anything. Try speaking louder."
            ],
            didntUnderstandResponses: [
                "I didn't understand that command. You can add custom commands in the settings.",
                "That's not a command I recognize. Check the settings to add new commands.",
                "I'm not sure what you mean. You can customize my responses in the settings panel.",
                "Sorry, I don't understand that. Try saying 'help' or check my available commands.",
                "I'm not familiar with that command. Would you like to add it to my settings?"
            ],
            speechErrorResponses: [
                "Sorry, I'm having trouble understanding you right now.",
                "There seems to be an issue with speech recognition. Please try again.",
                "I'm experiencing some difficulties hearing you. Could you repeat that?",
                "Something went wrong with listening. Let me try again."
            ],
            userCommands: {
                'hello': ['Hello! How can I help you today?'],
                'help': ['You can add your own commands in the settings. Try saying hello, time, or date.']
            },
            timeResponseFormat: 'The current time is {time}',
            dateResponseFormat: 'Today is {date}'
        };

        // Enhanced wake words, sleep words, and interruption words - now customizable
        let wakeWords = ['hey bot', 'hello bot', 'assistant', 'computer'];
        let sleepWords = ['sleep', 'go to sleep', 'sleep mode', 'rest', 'standby'];
        let interruptWords = ['stop', 'stop speaking', 'be quiet', 'shut up', 'halt', 'interrupt', 'pause', 'cancel'];
        
        // User-customizable commands and responses
        let userCommands = {
            // Example commands - user can modify these
            'hello': ['Hello! How can I help you today?'],
            'help': ['You can add your own commands in the settings. Try saying hello, time, or date.'],
            'open smart view': ['Opening Smart Hand Tracking View...', 'Loading Smart UI...', 'Activating hand tracking interface...'],
            'close smart view': ['Closing Smart View...', 'Returning to voice assistant...', 'Smart UI closed...'],
            'exit smart view': ['Exiting Smart View...', 'Back to main interface...']
        };
        
        // Default response when no command matches
        const defaultResponses = [
            "I didn't understand that command. You can add custom commands in the settings.",
            "That's not a command I recognize. Check the settings to add new commands.",
            "I'm not sure what you mean. You can customize my responses in the settings panel."
        ];
        
        // Ollama integration functions
        async function queryOllama(prompt) {
            const ollamaUrl = document.getElementById('ollamaUrl').value || 'http://localhost:11434';
            const ollamaModel = document.getElementById('ollamaModel').value || 'tinyllama';
            
            try {
                // Don't update status here - it's handled in handleAwakeInput
                const response = await fetch(`${ollamaUrl}/api/generate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: ollamaModel,
                        prompt: prompt,
                        stream: false,
                        options: {
                            temperature: 0.7,
                            max_tokens: 50,
                            top_p: 0.9
                        }
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Ollama API error: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Ollama response:', data);
                
                return data.response || 'Sorry, I couldn\'t generate a response.';
                
            } catch (error) {
                console.error('Ollama error:', error);
                
                // Don't show status here - let the fallback happen silently
                throw error; // Re-throw to let caller handle
            }
        }
        
        // Test Ollama connection
        async function testOllamaConnection() {
            const ollamaUrl = document.getElementById('ollamaUrl').value || 'http://localhost:11434';
            const statusDiv = document.getElementById('ollamaStatus');
            
            try {
                statusDiv.textContent = 'Testing connection...';
                statusDiv.style.color = '#f39c12';
                
                const response = await fetch(`${ollamaUrl}/api/tags`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const models = data.models || [];
                    const modelNames = models.map(m => m.name).join(', ');
                    
                    statusDiv.textContent = `‚úÖ Connected! Models: ${modelNames || 'None'}`;
                    statusDiv.style.color = '#27ae60';
                    
                    // Update model dropdown
                    updateOllamaModelList(models);
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
                
            } catch (error) {
                console.error('Ollama connection error:', error);
                statusDiv.textContent = `‚ùå Connection failed: ${error.message}`;
                statusDiv.style.color = '#e74c3c';
            }
        }
        
        // Update Ollama model list
        function updateOllamaModelList(models) {
            const modelSelect = document.getElementById('ollamaModel');
            const currentValue = modelSelect.value;
            
            // Clear existing options except the first default one
            modelSelect.innerHTML = '<option value="tinyllama">tinyllama (default)</option>';
            
            // Add detected models
            models.forEach(model => {
                if (model.name !== 'tinyllama') {
                    const option = document.createElement('option');
                    option.value = model.name;
                    option.textContent = model.name;
                    modelSelect.appendChild(option);
                }
            });
            
            // Restore previous selection if it exists
            if (currentValue && [...modelSelect.options].some(opt => opt.value === currentValue)) {
                modelSelect.value = currentValue;
            }
        }

        // Authorize Spotify using Web Playback SDK
        async function authorizeSpotify() {
            const clientId = document.getElementById('spotifyClientId').value;
            
            if (!clientId) {
                alert('Please enter your Spotify Client ID first');
                return;
            }
            
            // Get the current origin as redirect URI
            const redirectUri = window.location.origin + window.location.pathname;
            
            // Generate code verifier and challenge for PKCE
            const codeVerifier = generateCodeVerifier();
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            
            // Store code verifier for later use
            localStorage.setItem('spotify_code_verifier', codeVerifier);
            
            const scopes = [
                'streaming',
                'user-read-email',
                'user-read-private',
                'user-read-playback-state',
                'user-modify-playback-state',
                'user-read-currently-playing',
                'playlist-read-private',
                'playlist-read-collaborative'
            ].join(' ');
            
            const authUrl = `https://accounts.spotify.com/authorize?` +
                `response_type=code&` +
                `client_id=${encodeURIComponent(clientId)}&` +
                `scope=${encodeURIComponent(scopes)}&` +
                `redirect_uri=${encodeURIComponent(redirectUri)}&` +
                `code_challenge_method=S256&` +
                `code_challenge=${codeChallenge}&` +
                `state=${Math.random().toString(36).substring(7)}`;
            
            // Open authorization in new tab
            window.open(authUrl, '_blank');
            
            // Update status
            document.getElementById('spotifyStatus').textContent = '‚è≥ Authorization opened in new tab. Complete the process there.';
            document.getElementById('spotifyStatus').style.color = '#f39c12';
        }

        // Generate code verifier for PKCE
        function generateCodeVerifier() {
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
            const values = crypto.getRandomValues(new Uint8Array(128));
            return values.reduce((acc, x) => acc + possible[x % possible.length], '');
        }

        // Generate code challenge for PKCE
        async function generateCodeChallenge(codeVerifier) {
            const data = new TextEncoder().encode(codeVerifier);
            const digest = await window.crypto.subtle.digest('SHA-256', data);
            return btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        // Test Spotify connection
        async function testSpotifyConnection() {
            const statusDiv = document.getElementById('spotifyStatus');
            
            if (!spotifyAccessToken) {
                statusDiv.textContent = '‚ùå Not connected. Please authorize first.';
                statusDiv.style.color = '#e74c3c';
                return;
            }
            
            try {
                statusDiv.textContent = 'Testing connection...';
                statusDiv.style.color = '#f39c12';
                
                const response = await fetch('https://api.spotify.com/v1/me', {
                    headers: {
                        'Authorization': `Bearer ${spotifyAccessToken}`
                    }
                });
                
                if (response.ok) {
                    const userData = await response.json();
                    statusDiv.textContent = `‚úÖ Connected as ${userData.display_name}`;
                    statusDiv.style.color = '#27ae60';
                    
                    // Get available devices
                    await getSpotifyDevices();
                } else if (response.status === 401) {
                    statusDiv.textContent = '‚ùå Token expired. Please re-authorize.';
                    statusDiv.style.color = '#e74c3c';
                    spotifyAccessToken = null;
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('Spotify connection error:', error);
                statusDiv.textContent = `‚ùå Connection failed: ${error.message}`;
                statusDiv.style.color = '#e74c3c';
            }
        }

        // Get Spotify devices
        async function getSpotifyDevices() {
            if (!spotifyAccessToken) return;
            
            try {
                const response = await fetch('https://api.spotify.com/v1/me/player/devices', {
                    headers: {
                        'Authorization': `Bearer ${spotifyAccessToken}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const devices = data.devices || [];
                    
                    if (devices.length > 0) {
                        const activeDevice = devices.find(d => d.is_active) || devices[0];
                        spotifyDeviceId = activeDevice.id;
                        console.log('Active Spotify device:', activeDevice.name);
                    }
                }
            } catch (error) {
                console.error('Error getting Spotify devices:', error);
            }
        }

        // Spotify music control functions
        async function playSpotifyMusic(query = '') {
            if (!spotifyAccessToken) {
                return 'Please connect to Spotify first in the settings.';
            }
            
            try {
                if (query) {
                    // Search for music
                    const searchResponse = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track,artist,playlist&limit=1`, {
                        headers: {
                            'Authorization': `Bearer ${spotifyAccessToken}`
                        }
                    });
                    
                    if (searchResponse.ok) {
                        const searchData = await searchResponse.json();
                        let uri = null;
                        
                        if (searchData.tracks.items.length > 0) {
                            uri = searchData.tracks.items[0].uri;
                        } else if (searchData.artists.items.length > 0) {
                            uri = searchData.artists.items[0].uri;
                        } else if (searchData.playlists.items.length > 0) {
                            uri = searchData.playlists.items[0].uri;
                        }
                        
                        if (uri) {
                            const playResponse = await fetch('https://api.spotify.com/v1/me/player/play', {
                                method: 'PUT',
                                headers: {
                                    'Authorization': `Bearer ${spotifyAccessToken}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    uris: [uri],
                                    device_id: spotifyDeviceId
                                })
                            });
                            
                            if (playResponse.ok || playResponse.status === 204) {
                                return `Playing ${query} on Spotify.`;
                            }
                        } else {
                            return `Sorry, I couldn't find "${query}" on Spotify.`;
                        }
                    }
                } else {
                    // Resume playback
                    const playResponse = await fetch('https://api.spotify.com/v1/me/player/play', {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${spotifyAccessToken}`
                        },
                        body: JSON.stringify({
                            device_id: spotifyDeviceId
                        })
                    });
                    
                    if (playResponse.ok || playResponse.status === 204) {
                        return 'Resuming music on Spotify.';
                    }
                }
                
                return 'Sorry, there was an issue playing music on Spotify.';
                
            } catch (error) {
                console.error('Spotify play error:', error);
                return 'Sorry, there was an error with Spotify playback.';
            }
        }

        async function pauseSpotifyMusic() {
            if (!spotifyAccessToken) {
                return 'Please connect to Spotify first in the settings.';
            }
            
            try {
                const response = await fetch('https://api.spotify.com/v1/me/player/pause', {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${spotifyAccessToken}`
                    }
                });
                
                if (response.ok || response.status === 204) {
                    return 'Music paused on Spotify.';
                } else {
                    return 'Sorry, there was an issue pausing music on Spotify.';
                }
            } catch (error) {
                console.error('Spotify pause error:', error);
                return 'Sorry, there was an error pausing Spotify.';
            }
        }

        async function skipSpotifyTrack() {
            if (!spotifyAccessToken) {
                return 'Please connect to Spotify first in the settings.';
            }
            
            try {
                const response = await fetch('https://api.spotify.com/v1/me/player/next', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${spotifyAccessToken}`
                    }
                });
                
                if (response.ok || response.status === 204) {
                    return 'Skipped to next track on Spotify.';
                } else {
                    return 'Sorry, there was an issue skipping the track on Spotify.';
                }
            } catch (error) {
                console.error('Spotify skip error:', error);
                return 'Sorry, there was an error skipping the track.';
            }
        }

        async function previousSpotifyTrack() {
            if (!spotifyAccessToken) {
                return 'Please connect to Spotify first in the settings.';
            }
            
            try {
                const response = await fetch('https://api.spotify.com/v1/me/player/previous', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${spotifyAccessToken}`
                    }
                });
                
                if (response.ok || response.status === 204) {
                    return 'Playing previous track on Spotify.';
                } else {
                    return 'Sorry, there was an issue going to the previous track on Spotify.';
                }
            } catch (error) {
                console.error('Spotify previous error:', error);
                return 'Sorry, there was an error going to the previous track.';
            }
        }

        async function setSpotifyVolume(volume) {
            if (!spotifyAccessToken) {
                return 'Please connect to Spotify first in the settings.';
            }
            
            // Ensure volume is between 0 and 100
            volume = Math.max(0, Math.min(100, volume));
            
            try {
                const response = await fetch(`https://api.spotify.com/v1/me/player/volume?volume_percent=${volume}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${spotifyAccessToken}`
                    }
                });
                
                if (response.ok || response.status === 204) {
                    return `Set Spotify volume to ${volume}%.`;
                } else {
                    return 'Sorry, there was an issue setting the volume on Spotify.';
                }
            } catch (error) {
                console.error('Spotify volume error:', error);
                return 'Sorry, there was an error setting the volume.';
            }
        }

        async function getCurrentSpotifyTrack() {
            if (!spotifyAccessToken) {
                return 'Please connect to Spotify first in the settings.';
            }
            
            try {
                const response = await fetch('https://api.spotify.com/v1/me/player/currently-playing', {
                    headers: {
                        'Authorization': `Bearer ${spotifyAccessToken}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data && data.item) {
                        const track = data.item;
                        const artists = track.artists.map(artist => artist.name).join(', ');
                        const isPlaying = data.is_playing ? 'playing' : 'paused';
                        
                        return `Currently ${isPlaying}: "${track.name}" by ${artists}`;
                    } else {
                        return 'No music is currently playing on Spotify.';
                    }
                } else if (response.status === 204) {
                    return 'No music is currently playing on Spotify.';
                } else {
                    return 'Sorry, I couldn\'t get the current track information.';
                }
            } catch (error) {
                console.error('Spotify current track error:', error);
                return 'Sorry, there was an error getting the current track.';
            }
        }

        // Handle Spotify OAuth callback
        function handleSpotifyCallback() {
            // Check URL params for authorization code
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const error = urlParams.get('error');
            
            if (error) {
                console.error('Spotify authorization error:', error);
                document.getElementById('spotifyStatus').textContent = `‚ùå Authorization failed: ${error}`;
                document.getElementById('spotifyStatus').style.color = '#e74c3c';
                return;
            }
            
            if (code) {
                // Exchange code for access token
                exchangeSpotifyCode(code);
                
                // Clean up URL
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }

        // Exchange authorization code for access tokens
        async function exchangeSpotifyCode(code) {
            const clientId = document.getElementById('spotifyClientId').value;
            const codeVerifier = localStorage.getItem('spotify_code_verifier');
            
            if (!codeVerifier) {
                console.error('Code verifier not found');
                document.getElementById('spotifyStatus').textContent = '‚ùå Authorization error: missing code verifier';
                document.getElementById('spotifyStatus').style.color = '#e74c3c';
                return;
            }
            
            // Get the current origin as redirect URI
            const redirectUri = window.location.origin + window.location.pathname;
            
            try {
                document.getElementById('spotifyStatus').textContent = '‚è≥ Exchanging code for access token...';
                document.getElementById('spotifyStatus').style.color = '#f39c12';
                
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        client_id: clientId,
                        grant_type: 'authorization_code',
                        code: code,
                        redirect_uri: redirectUri,
                        code_verifier: codeVerifier,
                    }),
                });
                
                if (response.ok) {
                    const data = await response.json();
                    spotifyAccessToken = data.access_token;
                    spotifyRefreshToken = data.refresh_token;
                    
                    // Store tokens with expiration
                    const expirationTime = Date.now() + (data.expires_in * 1000);
                    localStorage.setItem('spotifyAccessToken', spotifyAccessToken);
                    localStorage.setItem('spotifyRefreshToken', spotifyRefreshToken);
                    localStorage.setItem('spotifyTokenExpiration', expirationTime.toString());
                    
                    // Clean up code verifier
                    localStorage.removeItem('spotify_code_verifier');
                    
                    document.getElementById('spotifyStatus').textContent = '‚úÖ Connected successfully!';
                    document.getElementById('spotifyStatus').style.color = '#27ae60';
                    
                    // Test connection and get devices
                    await testSpotifyConnection();
                    
                } else {
                    const errorData = await response.json();
                    throw new Error(errorData.error_description || 'Token exchange failed');
                }
                
            } catch (error) {
                console.error('Spotify token exchange error:', error);
                document.getElementById('spotifyStatus').textContent = `‚ùå Token exchange failed: ${error.message}`;
                document.getElementById('spotifyStatus').style.color = '#e74c3c';
                
                // Clean up code verifier
                localStorage.removeItem('spotify_code_verifier');
            }
        }

        // Check for Spotify token in localStorage or URL
        function checkForSpotifyToken() {
            // First check URL for authorization code
            handleSpotifyCallback();
            
            // If no token in URL, check localStorage
            if (!spotifyAccessToken) {
                const storedToken = localStorage.getItem('spotifyAccessToken');
                const storedRefreshToken = localStorage.getItem('spotifyRefreshToken');
                const tokenExpiration = localStorage.getItem('spotifyTokenExpiration');
                
                if (storedToken && tokenExpiration) {
                    if (Date.now() < parseInt(tokenExpiration)) {
                        // Token is still valid
                        spotifyAccessToken = storedToken;
                        spotifyRefreshToken = storedRefreshToken;
                        document.getElementById('spotifyStatus').textContent = '‚úÖ Previously connected';
                        document.getElementById('spotifyStatus').style.color = '#27ae60';
                    } else if (storedRefreshToken) {
                        // Token expired but we have a refresh token
                        refreshSpotifyToken();
                    } else {
                        // Token expired and no refresh token
                        localStorage.removeItem('spotifyAccessToken');
                        localStorage.removeItem('spotifyRefreshToken');
                        localStorage.removeItem('spotifyTokenExpiration');
                        document.getElementById('spotifyStatus').textContent = '‚ùå Token expired. Please re-authorize.';
                        document.getElementById('spotifyStatus').style.color = '#e74c3c';
                    }
                }
            }
        }

        // Refresh Spotify access token
        async function refreshSpotifyToken() {
            const clientId = document.getElementById('spotifyClientId').value;
            const refreshToken = localStorage.getItem('spotifyRefreshToken');
            
            if (!refreshToken) {
                document.getElementById('spotifyStatus').textContent = '‚ùå No refresh token. Please re-authorize.';
                document.getElementById('spotifyStatus').style.color = '#e74c3c';
                return;
            }
            
            try {
                document.getElementById('spotifyStatus').textContent = '‚è≥ Refreshing access token...';
                document.getElementById('spotifyStatus').style.color = '#f39c12';
                
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        client_id: clientId,
                        grant_type: 'refresh_token',
                        refresh_token: refreshToken,
                    }),
                });
                
                if (response.ok) {
                    const data = await response.json();
                    spotifyAccessToken = data.access_token;
                    
                    // Update refresh token if provided
                    if (data.refresh_token) {
                        spotifyRefreshToken = data.refresh_token;
                        localStorage.setItem('spotifyRefreshToken', spotifyRefreshToken);
                    }
                    
                    // Store new access token with expiration
                    const expirationTime = Date.now() + (data.expires_in * 1000);
                    localStorage.setItem('spotifyAccessToken', spotifyAccessToken);
                    localStorage.setItem('spotifyTokenExpiration', expirationTime.toString());
                    
                    document.getElementById('spotifyStatus').textContent = '‚úÖ Token refreshed successfully!';
                    document.getElementById('spotifyStatus').style.color = '#27ae60';
                    
                } else {
                    throw new Error('Token refresh failed');
                }
                
            } catch (error) {
                console.error('Spotify token refresh error:', error);
                document.getElementById('spotifyStatus').textContent = '‚ùå Token refresh failed. Please re-authorize.';
                document.getElementById('spotifyStatus').style.color = '#e74c3c';
                
                // Clean up stored tokens
                localStorage.removeItem('spotifyAccessToken');
                localStorage.removeItem('spotifyRefreshToken');
                localStorage.removeItem('spotifyTokenExpiration');
            }
        }
        
        // Load settings from localStorage
        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('voiceBotSettings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    
                    // Apply voice settings
                    document.getElementById('botVoice').value = settings.voice || defaultSettings.voice;
                    document.getElementById('botLanguage').value = settings.language || defaultSettings.language;
                    document.getElementById('botSpeed').value = settings.speed || defaultSettings.speed;
                    document.getElementById('botPitch').value = settings.pitch || defaultSettings.pitch;
                    document.getElementById('timeoutSelect').value = settings.timeout || defaultSettings.timeout;
                    
                    // Apply Ollama settings
                    document.getElementById('useOllama').checked = settings.useOllama || defaultSettings.useOllama;
                    document.getElementById('ollamaModel').value = settings.ollamaModel || defaultSettings.ollamaModel;
                    document.getElementById('ollamaUrl').value = settings.ollamaUrl || defaultSettings.ollamaUrl;
                    
                    // Apply Spotify settings
                    document.getElementById('useSpotify').checked = settings.useSpotify || defaultSettings.useSpotify;
                    document.getElementById('spotifyClientId').value = settings.spotifyClientId || defaultSettings.spotifyClientId;
                    
                    // Apply absence greeting settings
                    document.getElementById('useAbsenceGreeting').checked = settings.useAbsenceGreeting !== undefined ? settings.useAbsenceGreeting : defaultSettings.useAbsenceGreeting;
                    document.getElementById('absenceMinutes').value = settings.absenceMinutes || defaultSettings.absenceMinutes;
                    document.getElementById('morningGreeting').value = settings.morningGreeting || defaultSettings.morningGreeting;
                    document.getElementById('afternoonGreeting').value = settings.afternoonGreeting || defaultSettings.afternoonGreeting;
                    document.getElementById('eveningGreeting').value = settings.eveningGreeting || defaultSettings.eveningGreeting;
                    document.getElementById('nightGreeting').value = settings.nightGreeting || defaultSettings.nightGreeting;
                    document.getElementById('greetingCustomMessage').value = settings.greetingCustomMessage || defaultSettings.greetingCustomMessage;
                    document.getElementById('openSettingsPhrase').value = settings.openSettingsPhrase || defaultSettings.openSettingsPhrase;
                    document.getElementById('settingsPassword').value = settings.settingsPassword || defaultSettings.settingsPassword;
                    
                    // Apply reminder settings
                    document.getElementById('useReminders').checked = settings.useReminders !== undefined ? settings.useReminders : defaultSettings.useReminders;
                    document.getElementById('requireReminderConfirmation').checked = settings.requireReminderConfirmation !== undefined ? settings.requireReminderConfirmation : defaultSettings.requireReminderConfirmation;
                    document.getElementById('maxReminders').value = settings.maxReminders || defaultSettings.maxReminders;
                    document.getElementById('reminderSnooze').value = settings.reminderSnooze || defaultSettings.reminderSnooze;
                    document.getElementById('missedReminderMessage').value = settings.missedReminderMessage || defaultSettings.missedReminderMessage;
                    
                    // Apply mobile optimization settings
                    const mobileOptEnabled = settings.mobileOptimization !== undefined ? settings.mobileOptimization : isMobileDevice;
                    document.getElementById('mobileOptimization').checked = mobileOptEnabled;
                    mobileOptimizationEnabled = mobileOptEnabled;
                    
                    // Apply mobile push-to-talk and auto-sleep settings
                    // On mobile, always enable push-to-talk when mobile optimization is on
                    if (isMobileDevice && mobileOptEnabled) {
                        document.getElementById('mobilePushToTalk').checked = true;
                    } else {
                        document.getElementById('mobilePushToTalk').checked = settings.mobilePushToTalk || false;
                    }
                    document.getElementById('disableMobileAutoSleep').checked = settings.disableMobileAutoSleep || false;
                    
                    // Apply wake, sleep, and interrupt words
                    wakeWords = settings.wakeWords || defaultSettings.wakeWords;
                    sleepWords = settings.sleepWords || defaultSettings.sleepWords;
                    interruptWords = settings.interruptWords || defaultSettings.interruptWords;
                    
                    // Apply fallback responses
                    noSpeechResponses = settings.noSpeechResponses || defaultSettings.noSpeechResponses;
                    didntUnderstandResponses = settings.didntUnderstandResponses || defaultSettings.didntUnderstandResponses;
                    speechErrorResponses = settings.speechErrorResponses || defaultSettings.speechErrorResponses;
                    
                    // Apply normal wake responses
                    normalWakeResponses = settings.normalWakeResponses || defaultSettings.normalWakeResponses;
                    
                    // Apply sleep responses
                    sleepResponses = settings.sleepResponses || defaultSettings.sleepResponses;
                    
                    // Apply use fallback responses setting
                    document.getElementById('useFallbackResponses').checked = settings.useFallbackResponses !== undefined ? settings.useFallbackResponses : defaultSettings.useFallbackResponses;
                    
                    // Populate fallback response input fields
                    document.getElementById('noSpeechInput').value = noSpeechResponses.join(', ');
                    document.getElementById('didntUnderstandInput').value = didntUnderstandResponses.join(', ');
                    document.getElementById('speechErrorInput').value = speechErrorResponses.join(', ');
                    
                    // Populate normal wake responses input field
                    document.getElementById('normalWakeResponses').value = normalWakeResponses.join(', ');
                    
                    // Populate sleep responses input field
                    document.getElementById('sleepResponses').value = sleepResponses.join(', ');
                    
                    // Apply user commands
                    userCommands = settings.userCommands || defaultSettings.userCommands;
                    
                    // Apply time and date response formats
                    document.getElementById('timeResponseFormat').value = settings.timeResponseFormat || defaultSettings.timeResponseFormat;
                    document.getElementById('dateResponseFormat').value = settings.dateResponseFormat || defaultSettings.dateResponseFormat;
                    
                    console.log('Settings loaded successfully');
                    
                    // Update mobile optimization UI
                    toggleMobileOptimization();
                    
                    return true;
                } else {
                    console.log('No saved settings found, using defaults');
                    // Populate fallback response input fields with defaults
                    document.getElementById('noSpeechInput').value = defaultSettings.noSpeechResponses.join(', ');
                    document.getElementById('didntUnderstandInput').value = defaultSettings.didntUnderstandResponses.join(', ');
                    document.getElementById('speechErrorInput').value = defaultSettings.speechErrorResponses.join(', ');
                    // Populate missed reminder message with default
                    document.getElementById('missedReminderMessage').value = defaultSettings.missedReminderMessage;
                    // Populate normal wake responses with defaults
                    document.getElementById('normalWakeResponses').value = defaultSettings.normalWakeResponses.join(', ');
                    // Populate sleep responses with defaults
                    document.getElementById('sleepResponses').value = defaultSettings.sleepResponses.join(', ');
                    // Populate settings phrase with default
                    document.getElementById('openSettingsPhrase').value = defaultSettings.openSettingsPhrase;
                    // Populate settings password with default
                    document.getElementById('settingsPassword').value = defaultSettings.settingsPassword;
                    // Set use fallback responses checkbox to default
                    document.getElementById('useFallbackResponses').checked = defaultSettings.useFallbackResponses;
                    // Populate time and date formats with defaults
                    document.getElementById('timeResponseFormat').value = defaultSettings.timeResponseFormat;
                    document.getElementById('dateResponseFormat').value = defaultSettings.dateResponseFormat;
                    return false;
                }
            } catch (error) {
                console.error('Error loading settings:', error);
                return false;
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            try {
                const settings = {
                    voice: document.getElementById('botVoice').value,
                    language: document.getElementById('botLanguage').value,
                    speed: document.getElementById('botSpeed').value,
                    pitch: document.getElementById('botPitch').value,
                    timeout: document.getElementById('timeoutSelect').value,
                    useOllama: document.getElementById('useOllama').checked,
                    ollamaModel: document.getElementById('ollamaModel').value,
                    ollamaUrl: document.getElementById('ollamaUrl').value,
                    useSpotify: document.getElementById('useSpotify').checked,
                    spotifyClientId: document.getElementById('spotifyClientId').value,
                    useAbsenceGreeting: document.getElementById('useAbsenceGreeting').checked,
                    absenceMinutes: parseInt(document.getElementById('absenceMinutes').value),
                    morningGreeting: document.getElementById('morningGreeting').value,
                    afternoonGreeting: document.getElementById('afternoonGreeting').value,
                    eveningGreeting: document.getElementById('eveningGreeting').value,
                    nightGreeting: document.getElementById('nightGreeting').value,
                    greetingCustomMessage: document.getElementById('greetingCustomMessage').value,
                    openSettingsPhrase: document.getElementById('openSettingsPhrase').value,
                    settingsPassword: document.getElementById('settingsPassword').value,
                    useReminders: document.getElementById('useReminders').checked,
                    requireReminderConfirmation: document.getElementById('requireReminderConfirmation').checked,
                    maxReminders: parseInt(document.getElementById('maxReminders').value),
                    reminderSnooze: parseInt(document.getElementById('reminderSnooze').value),
                    missedReminderMessage: document.getElementById('missedReminderMessage').value,
                    mobileOptimization: document.getElementById('mobileOptimization').checked,
                    mobilePushToTalk: document.getElementById('mobilePushToTalk').checked,
                    disableMobileAutoSleep: document.getElementById('disableMobileAutoSleep').checked,
                    wakeWords: wakeWords,
                    sleepWords: sleepWords,
                    interruptWords: interruptWords,
                    userCommands: userCommands,
                    noSpeechResponses: noSpeechResponses,
                    didntUnderstandResponses: didntUnderstandResponses,
                    speechErrorResponses: speechErrorResponses,
                    normalWakeResponses: normalWakeResponses,
                    sleepResponses: sleepResponses,
                    useFallbackResponses: document.getElementById('useFallbackResponses').checked,
                    timeResponseFormat: document.getElementById('timeResponseFormat').value,
                    dateResponseFormat: document.getElementById('dateResponseFormat').value
                };
                
                localStorage.setItem('voiceBotSettings', JSON.stringify(settings));
                console.log('Settings saved successfully');
                return true;
            } catch (error) {
                console.error('Error saving settings:', error);
                return false;
            }
        }

        // Export settings to JSON file
        function exportSettings() {
            try {
                const settings = {
                    voice: document.getElementById('botVoice').value,
                    language: document.getElementById('botLanguage').value,
                    speed: document.getElementById('botSpeed').value,
                    pitch: document.getElementById('botPitch').value,
                    timeout: document.getElementById('timeoutSelect').value,
                    useOllama: document.getElementById('useOllama').checked,
                    ollamaModel: document.getElementById('ollamaModel').value,
                    ollamaUrl: document.getElementById('ollamaUrl').value,
                    useEveningGreeting: document.getElementById('useEveningGreeting').checked,
                    eveningGreetingTime: document.getElementById('eveningGreetingTime').value,
                    eveningGreetingMessage: document.getElementById('eveningGreetingMessage').value,
                    useReminders: document.getElementById('useReminders').checked,
                    requireReminderConfirmation: document.getElementById('requireReminderConfirmation').checked,
                    maxReminders: parseInt(document.getElementById('maxReminders').value),
                    reminderSnooze: parseInt(document.getElementById('reminderSnooze').value),
                    wakeWords: wakeWords,
                    sleepWords: sleepWords,
                    interruptWords: interruptWords,
                    userCommands: userCommands,
                    exportDate: new Date().toISOString()
                };
                
                const dataStr = JSON.stringify(settings, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = 'voice-bot-settings.json';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                alert('Settings exported successfully!');
            } catch (error) {
                console.error('Error exporting settings:', error);
                alert('Error exporting settings. Please try again.');
            }
        }

        // Import settings from JSON file
        function importSettings() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedSettings = JSON.parse(e.target.result);
                            
                            // Validate settings structure
                            if (importedSettings && typeof importedSettings === 'object') {
                                // Apply imported settings
                                if (importedSettings.voice) document.getElementById('botVoice').value = importedSettings.voice;
                                if (importedSettings.language) document.getElementById('botLanguage').value = importedSettings.language;
                                if (importedSettings.speed) document.getElementById('botSpeed').value = importedSettings.speed;
                                if (importedSettings.pitch) document.getElementById('botPitch').value = importedSettings.pitch;
                                if (importedSettings.timeout) document.getElementById('timeoutSelect').value = importedSettings.timeout;
                                
                                if (importedSettings.useOllama !== undefined) document.getElementById('useOllama').checked = importedSettings.useOllama;
                                if (importedSettings.ollamaModel) document.getElementById('ollamaModel').value = importedSettings.ollamaModel;
                                if (importedSettings.ollamaUrl) document.getElementById('ollamaUrl').value = importedSettings.ollamaUrl;
                                
                                if (importedSettings.useEveningGreeting !== undefined) document.getElementById('useEveningGreeting').checked = importedSettings.useEveningGreeting;
                                if (importedSettings.eveningGreetingTime) document.getElementById('eveningGreetingTime').value = importedSettings.eveningGreetingTime;
                                if (importedSettings.eveningGreetingMessage) document.getElementById('eveningGreetingMessage').value = importedSettings.eveningGreetingMessage;
                                
                                if (importedSettings.useReminders !== undefined) document.getElementById('useReminders').checked = importedSettings.useReminders;
                                if (importedSettings.requireReminderConfirmation !== undefined) document.getElementById('requireReminderConfirmation').checked = importedSettings.requireReminderConfirmation;
                                if (importedSettings.maxReminders) document.getElementById('maxReminders').value = importedSettings.maxReminders;
                                if (importedSettings.reminderSnooze) document.getElementById('reminderSnooze').value = importedSettings.reminderSnooze;
                                if (importedSettings.openSettingsPhrase) document.getElementById('openSettingsPhrase').value = importedSettings.openSettingsPhrase;
                                if (importedSettings.settingsPassword) document.getElementById('settingsPassword').value = importedSettings.settingsPassword;
                                
                                if (importedSettings.wakeWords) wakeWords = importedSettings.wakeWords;
                                if (importedSettings.sleepWords) sleepWords = importedSettings.sleepWords;
                                if (importedSettings.interruptWords) interruptWords = importedSettings.interruptWords;
                                if (importedSettings.userCommands) userCommands = importedSettings.userCommands;
                                if (importedSettings.normalWakeResponses) normalWakeResponses = importedSettings.normalWakeResponses;
                                if (importedSettings.sleepResponses) sleepResponses = importedSettings.sleepResponses;
                                
                                // Update displays
                                updatePitchDisplay();
                                updateTimeoutDisplay();
                                updateWakeWordsDisplay();
                                updateCommandsDisplay();
                                updateCommandsList();
                                
                                // Update input fields
                                document.getElementById('wakeWordInput').value = wakeWords.join(', ');
                                document.getElementById('sleepWordInput').value = sleepWords.join(', ');
                                document.getElementById('interruptWordInput').value = interruptWords.join(', ');
                                document.getElementById('normalWakeResponses').value = normalWakeResponses.join(', ');
                                document.getElementById('sleepResponses').value = sleepResponses.join(', ');
                                
                                // Save to localStorage
                                saveSettings();
                                
                                alert('Settings imported successfully!');
                            } else {
                                alert('Invalid settings file format.');
                            }
                        } catch (error) {
                            console.error('Error importing settings:', error);
                            alert('Error reading settings file. Please check the file format.');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            
            input.click();
        }

        // Reset all settings to defaults
        function resetAllSettings() {
            if (confirm('Are you sure you want to reset ALL settings to defaults? This will clear all custom commands, wake words, and voice settings.')) {
                // Reset to defaults
                document.getElementById('botVoice').value = defaultSettings.voice;
                document.getElementById('botLanguage').value = defaultSettings.language;
                document.getElementById('botSpeed').value = defaultSettings.speed;
                document.getElementById('botPitch').value = defaultSettings.pitch;
                document.getElementById('timeoutSelect').value = defaultSettings.timeout;
                
                document.getElementById('useOllama').checked = defaultSettings.useOllama;
                document.getElementById('ollamaModel').value = defaultSettings.ollamaModel;
                document.getElementById('ollamaUrl').value = defaultSettings.ollamaUrl;
                
                document.getElementById('useEveningGreeting').checked = defaultSettings.useEveningGreeting;
                document.getElementById('eveningGreetingTime').value = defaultSettings.eveningGreetingTime;
                document.getElementById('eveningGreetingMessage').value = defaultSettings.eveningGreetingMessage;
                
                document.getElementById('useReminders').checked = defaultSettings.useReminders;
                document.getElementById('requireReminderConfirmation').checked = defaultSettings.requireReminderConfirmation;
                document.getElementById('maxReminders').value = defaultSettings.maxReminders;
                document.getElementById('reminderSnooze').value = defaultSettings.reminderSnooze;
                
                wakeWords = [...defaultSettings.wakeWords];
                sleepWords = [...defaultSettings.sleepWords];
                normalWakeResponses = [...defaultSettings.normalWakeResponses];
                sleepResponses = [...defaultSettings.sleepResponses];
                userCommands = JSON.parse(JSON.stringify(defaultSettings.userCommands));
                
                // Update displays
                updatePitchDisplay();
                updateTimeoutDisplay();
                updateWakeWordsDisplay();
                updateCommandsDisplay();
                updateCommandsList();
                
                // Update input fields
                document.getElementById('wakeWordInput').value = wakeWords.join(', ');
                document.getElementById('sleepWordInput').value = sleepWords.join(', ');
                document.getElementById('normalWakeResponses').value = normalWakeResponses.join(', ');
                document.getElementById('sleepResponses').value = sleepResponses.join(', ');
                
                // Clear localStorage
                localStorage.removeItem('voiceBotSettings');
                
                alert('All settings have been reset to defaults.');
            }
        }
        
        async function getMicrophones() {
            try {
                // First, request microphone permission
                await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Then get the list of devices
                const devices = await navigator.mediaDevices.enumerateDevices();
                availableMicrophones = devices.filter(device => device.kind === 'audioinput');
                
                console.log('Available microphones:', availableMicrophones);
                return availableMicrophones;
            } catch (error) {
                console.error('Error getting microphones:', error);
                updateStatus('‚ùå Microphone Access Denied', 'Please grant microphone permissions to use voice features');
                return [];
            }
        }

        // Populate microphone dropdown
        async function populateMicrophoneSelect() {
            const micSelect = document.getElementById('microphoneSelect');
            const mics = await getMicrophones();
            
            // Clear existing options except default
            micSelect.innerHTML = '<option value="default">Default Microphone</option>';
            
            // Add available microphones
            mics.forEach((mic, index) => {
                const option = document.createElement('option');
                option.value = mic.deviceId;
                option.textContent = mic.label || `Microphone ${index + 1}`;
                micSelect.appendChild(option);
            });
            
            // Add change event listener
            micSelect.addEventListener('change', function() {
                selectedMicrophoneId = this.value === 'default' ? null : this.value;
                console.log('Selected microphone:', selectedMicrophoneId);
                
                // If bot is active, restart with new microphone
                if (isBotActive) {
                    restartBotWithNewMicrophone();
                }
            });
        }

        // Refresh microphones list
        async function refreshMicrophones() {
            updateStatus('üîÑ Refreshing Microphones', 'Scanning for available audio input devices...');
            await populateMicrophoneSelect();
            updateStatus('‚úÖ Microphones Updated', 'Audio device list has been refreshed and updated');
        }

        // Calculate string similarity to detect bot's own speech
        function calculateStringSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const distance = levenshteinDistance(longer, shorter);
            return (longer.length - distance) / longer.length;
        }
        
        function levenshteinDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }

        // Restart bot with new microphone
        function restartBotWithNewMicrophone() {
            if (isBotActive) {
                console.log('Restarting bot with new microphone...');
                updateStatus('üîÑ Switching Microphone', 'Restarting with selected microphone...');
                
                // Stop current recognition
                if (speechRecognition) {
                    speechRecognition.stop();
                }
                
                // Wait a moment then restart
                setTimeout(() => {
                    if (isBotActive) {
                        initBot();
                        speechRecognition.start();
                        updateStatus('üéôÔ∏è Microphone Changed', 'Successfully switched to new microphone');
                    }
                }, 500);
            }
        }
        
        // Initialize the bot
        async function initBot() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                updateStatus('‚ùå Speech Recognition Not Available', 'Your browser doesn\'t support speech recognition. Please try Chrome or Edge.');
                return false;
            }

            // Initialize audio context and microphone stream for voice activity detection
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const constraints = {
                    audio: selectedMicrophoneId ? 
                        { deviceId: { exact: selectedMicrophoneId } } : 
                        { 
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                };
                
                microphoneStream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log('Microphone access granted');
                
                // Initialize voice activity detection for mobile optimization
                if (isMobileDevice && mobileOptimizationEnabled) {
                    voiceActivityDetector = initVoiceActivityDetection();
                    console.log('Voice activity detection initialized for mobile');
                }
                
            } catch (error) {
                console.error('Failed to access microphone:', error);
                updateStatus('‚ö†Ô∏è Microphone Access Issue', 'Please allow microphone access and try again');
                return false;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            speechRecognition = new SpeechRecognition();
            
            // Mobile-optimized speech recognition settings
            if (isMobileDevice && mobileOptimizationEnabled) {
                speechRecognition.continuous = false; // Disable continuous mode on mobile
                speechRecognition.interimResults = false; // Disable interim results on mobile
                console.log('Mobile optimization enabled: continuous=false, interimResults=false');
            } else {
                speechRecognition.continuous = true;
                speechRecognition.interimResults = true;
            }
            speechRecognition.lang = document.getElementById('botLanguage').value;

            speechRecognition.onstart = () => {
                isListening = true;
                updateBotAvatar('listening', 'üëÇ');
                updateStatus('üéôÔ∏è Listening for Wake Words', 'Say your custom wake words to wake me up');
            };

            speechRecognition.onresult = (event) => {
                // Check for interrupt words immediately, even in interim results
                let interimTranscript = '';
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript.toLowerCase().trim();
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                // Check all transcripts (both interim and final) for interrupt words
                const allTranscript = (finalTranscript + ' ' + interimTranscript).toLowerCase().trim();
                const containsInterruptWord = interruptWords.some(word => allTranscript.includes(word));
                
                if (containsInterruptWord) {
                    console.log('Interrupt word detected:', allTranscript);
                    interruptBot(allTranscript);
                    return;
                }
                
                // Special handling for motion detection mode - only listen for stop command
                if (motionDetectionActive) {
                    const stopMotionPhrases = [
                        "don't detect motion",
                        "stop detecting motion",
                        "turn off motion detection",
                        "disable motion detection",
                        "stop looking",
                        "close camera",
                        "turn off camera"
                    ];
                    
                    const shouldStopMotion = stopMotionPhrases.some(phrase => 
                        allTranscript.includes(phrase)
                    );
                    
                    if (shouldStopMotion) {
                        console.log('Stop motion detection command detected:', allTranscript);
                        
                        // If it's a camera stop command, close camera (which also stops motion detection)
                        if (allTranscript.includes('stop looking') || allTranscript.includes('close camera') || allTranscript.includes('turn off camera')) {
                            closeCameraView();
                            addMessage('user', allTranscript);
                            addMessage('bot', "I've stopped looking. Camera is now off and motion detection has stopped.");
                            speak("I've stopped looking. Camera is now off and motion detection has stopped.");
                        } else {
                            stopMotionDetection();
                            addMessage('user', allTranscript);
                            addMessage('bot', "Motion detection stopped. I'm listening for all commands again.");
                            speak("Motion detection stopped. I'm listening for all commands again.");
                        }
                    } else {
                        console.log('Motion detection active - ignoring other speech:', allTranscript);
                    }
                    return;
                }
                
                // Skip processing other commands if bot is currently speaking (unless it's an interrupt)
                if (isSpeaking) {
                    console.log('Bot is speaking, only checking for interrupts');
                    return;
                }
                
                // Skip if we just finished speaking (within 5 seconds)
                const timeSinceSpeech = Date.now() - botSpeechStartTime;
                const timeSinceEnd = Date.now() - botSpeechEndTime;
                if (timeSinceSpeech < 5000 || timeSinceEnd < 3000) {
                    console.log('Ignoring speech - too soon after bot speech');
                    return;
                }
                
                // Check if the detected speech matches what the bot just said
                if (lastSpokenText && allTranscript.length > 3) {
                    const similarity = calculateStringSimilarity(allTranscript, lastSpokenText);
                    if (similarity > 0.6) {
                        console.log('Ignoring bot\'s own echo:', allTranscript);
                        return;
                    }
                }
                
                // Check if the detected speech contains bot's own phrases (self-filtering)
                const botPhrases = [
                    'the current time is', 'pm', 'am', 'motion detected', 'hello', 
                    'listening', 'how can i help', 'i see', 'people in view',
                    'i am awake', 'what can i do for you', 'welcome back'
                ];
                const containsBotPhrase = botPhrases.some(phrase => allTranscript.includes(phrase));
                if (containsBotPhrase) {
                    console.log('Ignoring bot\'s own speech:', allTranscript);
                    return;
                }

                if (finalTranscript) {
                    // Additional filters to prevent feedback
                    if (!containsBotResponse(finalTranscript) && 
                        !isSimilarToLastResponse(finalTranscript) &&
                        finalTranscript.length > 2) {
                        console.log('Processing user input:', finalTranscript);
                        processUserInput(finalTranscript);
                    } else {
                        console.log('Filtered out potential bot echo:', finalTranscript);
                    }
                }
            };

            speechRecognition.onend = () => {
                isListening = false;
                console.log('Speech recognition ended');
                
                // Clear any existing restart timeout
                if (restartTimeout) {
                    clearTimeout(restartTimeout);
                    restartTimeout = null;
                }
                
                if (isBotActive && !isSpeaking) {
                    // Mobile-optimized restart logic
                    if (isMobileDevice && mobileOptimizationEnabled) {
                        // On mobile, wait longer and only restart if there was recent activity
                        const timeSinceActivity = Date.now() - lastMicrophoneActivity;
                        const shouldRestart = timeSinceActivity < 10000; // 10 seconds
                        
                        if (shouldRestart) {
                            restartTimeout = setTimeout(() => {
                                if (isBotActive && !isSpeaking && !isListening) {
                                    try {
                                        console.log('Mobile: Restarting speech recognition after activity');
                                        speechRecognition.start();
                                    } catch (e) {
                                        console.log('Mobile restart failed:', e);
                                        // Wait longer before next attempt
                                        setTimeout(() => {
                                            if (isBotActive && !isSpeaking && !isListening) {
                                                try {
                                                    speechRecognition.start();
                                                } catch (e2) {
                                                    console.log('Mobile retry restart failed:', e2);
                                                }
                                            }
                                        }, 3000);
                                    }
                                }
                            }, 2000); // Wait 2 seconds on mobile
                        } else {
                            console.log('Mobile: Not restarting due to inactivity');
                            updateStatus('üì± Mobile Mode - Waiting', 'Speak to reactivate listening');
                            
                            // Set up a periodic restart attempt for mobile
                            restartTimeout = setTimeout(() => {
                                if (isBotActive && !isSpeaking && !isListening) {
                                    try {
                                        console.log('Mobile: Periodic restart attempt');
                                        speechRecognition.start();
                                    } catch (e) {
                                        console.log('Mobile periodic restart failed:', e);
                                    }
                                }
                            }, 15000); // Try again in 15 seconds
                        }
                    } else {
                        // Desktop: Use original quick restart logic
                        restartTimeout = setTimeout(() => {
                            if (isBotActive && !isSpeaking && !isListening) {
                                try {
                                    console.log('Desktop: Restarting speech recognition');
                                    speechRecognition.start();
                                } catch (e) {
                                    console.log('Desktop restart failed:', e);
                                }
                            }
                        }, 500);
                    }
                } else if (!isBotActive) {
                    updateBotAvatar('idle', 'ü§ñ');
                    updateStatus('üí§ Assistant Deactivated', 'Click "Activate Assistant" to start');
                }
            };

            speechRecognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                isListening = false;
                
                // Don't try to restart on abort or while speaking
                if (event.error === 'aborted' || isSpeaking) {
                    console.log('Recognition aborted or speaking, not restarting');
                    return;
                }
                
                // Only restart on recoverable errors and if bot is active
                if (isBotActive && !isSpeaking && 
                    ['network', 'audio-capture', 'no-speech'].includes(event.error)) {
                    setTimeout(() => {
                        if (isBotActive && !isSpeaking && !isListening) {
                            try {
                                console.log('Attempting error recovery restart');
                                speechRecognition.start();
                            } catch (e) {
                                console.log('Error recovery restart failed:', e);
                            }
                        }
                    }, 2000);
                }
            };

            return true;
        }

        // Check if input contains bot response patterns (to avoid feedback)
        function containsBotResponse(input) {
            const botPatterns = [
                'yes sir', 'ready', 'listening', 'here', 'go ahead',
                'going to sleep', 'sleep mode', 'resting now', 'standby', 'good night', 'sleeping',
                'i didnt understand', 'not a command', 'check the settings',
                'you can add', 'customize my responses'
            ];
            
            return botPatterns.some(pattern => input.includes(pattern));
        }

        // Check if input is similar to the last bot response
        function isSimilarToLastResponse(input) {
            if (!lastBotResponse) return false;
            
            const similarity = calculateSimilarity(input, lastBotResponse.toLowerCase());
            return similarity > 0.7; // 70% similarity threshold
        }

        // Simple similarity calculation
        function calculateSimilarity(str1, str2) {
            const words1 = str1.split(' ');
            const words2 = str2.split(' ');
            
            let matches = 0;
            words1.forEach(word => {
                if (words2.includes(word) && word.length > 2) {
                    matches++;
                }
            });
            
            return matches / Math.max(words1.length, words2.length);
        }

        // Process user input with enhanced pattern matching
        function processUserInput(input) {
            console.log('Processing input:', input);
            
            // Check for interruption words first - highest priority
            const containsInterruptWord = interruptWords.some(word => input.includes(word));
            if (containsInterruptWord) {
                interruptBot(input);
                return;
            }
            
            const containsWakeWord = wakeWords.some(word => input.includes(word));
            const containsSleepWord = sleepWords.some(word => input.includes(word));
            
            if (containsWakeWord && !isAwake) {
                wakeUpBot(input);
            } else if (containsSleepWord && isAwake) {
                sleepBot(input);
            } else if (isAwake) {
                handleAwakeInput(input);
            }
        }

        // Wake up the bot with short acknowledgment
        function wakeUpBot(input) {
            isAwake = true;
            conversationCount++;
            updateStats();
            
            addMessage('user', input);
            
            // Check for missed reminders first
            const missedReminders = checkForMissedReminders();
            if (missedReminders.length > 0) {
                announceMissedReminders(missedReminders);
                return; // Exit early to announce missed reminders first
            }
            
            // Smart wake: Check if there's a command after the wake word
            const commandAfterWake = extractCommandAfterWakeWord(input);
            
            if (commandAfterWake) {
                // User provided a command with the wake word, process it directly
                console.log('Smart wake detected command:', commandAfterWake);
                
                // Update last interaction time
                lastInteractionTime = new Date().getTime();
                localStorage.setItem('lastInteractionTime', lastInteractionTime.toString());
                
                // Process the command directly without a wake response
                handleAwakeInput(commandAfterWake);
                
                // Set sleep timer
                resetSleepTimer();
                return;
            }
            
            let response;
            
            // Check if absence greeting should be used
            const useAbsenceGreeting = document.getElementById('useAbsenceGreeting').checked;
            const absenceMinutes = parseInt(document.getElementById('absenceMinutes').value) || 30;
            
            if (useAbsenceGreeting && !absenceGreetingGiven && shouldShowAbsenceGreeting(absenceMinutes)) {
                response = getTimeBasedGreeting();
                absenceGreetingGiven = true; // Mark as given to prevent repeating until next absence
            } else {
                // Use customizable normal wake responses
                const wakeResponses = normalWakeResponses.length > 0 ? normalWakeResponses : defaultSettings.normalWakeResponses;
                response = wakeResponses[Math.floor(Math.random() * wakeResponses.length)];
            }
            
            // Update last interaction time
            lastInteractionTime = new Date().getTime();
            localStorage.setItem('lastInteractionTime', lastInteractionTime.toString());
            
            respondToUser(response);
            
            // Set sleep timer
            resetSleepTimer();
        }
        
        // Extract command after wake word for smart wake functionality
        function extractCommandAfterWakeWord(input) {
            const lowerInput = input.toLowerCase().trim();
            
            // Find which wake word was used and prioritize those at the beginning
            let usedWakeWord = null;
            let wakeWordPosition = -1;
            
            // First check if any wake word starts the input (most natural)
            for (const wakeWord of wakeWords) {
                if (lowerInput.startsWith(wakeWord.toLowerCase())) {
                    usedWakeWord = wakeWord;
                    wakeWordPosition = 0;
                    break;
                }
            }
            
            // If no wake word at start, check anywhere in the input
            if (!usedWakeWord) {
                for (const wakeWord of wakeWords) {
                    const position = lowerInput.indexOf(wakeWord.toLowerCase());
                    if (position !== -1) {
                        usedWakeWord = wakeWord;
                        wakeWordPosition = position;
                        break;
                    }
                }
            }
            
            if (!usedWakeWord) {
                return null; // No wake word found
            }
            
            // Extract text after the wake word
            const afterWakeWord = lowerInput.substring(wakeWordPosition + usedWakeWord.length).trim();
            
            // If there's meaningful content after the wake word, return it
            if (afterWakeWord.length > 0) {
                // Filter out common filler words and check if there's actual content
                const fillerWords = ['please', 'can you', 'could you', 'would you', 'will you', 'i want', 'i need', 'help me'];
                let cleanCommand = afterWakeWord;
                
                // Remove filler words from the beginning
                for (const filler of fillerWords) {
                    if (cleanCommand.startsWith(filler)) {
                        cleanCommand = cleanCommand.substring(filler.length).trim();
                        break;
                    }
                }
                
                // If there's still meaningful content after removing fillers, it's a valid command
                if (cleanCommand.length > 2) { // At least 3 characters for a meaningful command
                    // Return the original casing from the input for better processing
                    const originalAfterWake = input.substring(wakeWordPosition + usedWakeWord.length).trim();
                    
                    // Remove filler words from original text too
                    let originalCleanCommand = originalAfterWake;
                    for (const filler of fillerWords) {
                        if (originalCleanCommand.toLowerCase().startsWith(filler)) {
                            originalCleanCommand = originalCleanCommand.substring(filler.length).trim();
                            break;
                        }
                    }
                    
                    return originalCleanCommand;
                }
            }
            
            return null; // No command found after wake word
        }

        // Check if absence greeting should be shown
        function shouldShowAbsenceGreeting(requiredMinutes) {
            if (!lastInteractionTime) {
                // First time using the bot, show greeting
                return true;
            }
            
            const now = new Date().getTime();
            const timeSinceLastInteraction = (now - lastInteractionTime) / (1000 * 60); // Convert to minutes
            
            return timeSinceLastInteraction >= requiredMinutes;
        }
        
        // Get time-appropriate greeting message
        function getTimeBasedGreeting() {
            const now = new Date();
            const hour = now.getHours();
            
            let greeting;
            
            // Determine time period and get appropriate greeting
            if (hour >= 6 && hour < 12) {
                // Morning: 6:00 - 11:59
                greeting = document.getElementById('morningGreeting').value || defaultSettings.morningGreeting;
            } else if (hour >= 12 && hour < 18) {
                // Afternoon: 12:00 - 17:59
                greeting = document.getElementById('afternoonGreeting').value || defaultSettings.afternoonGreeting;
            } else if (hour >= 18 && hour < 22) {
                // Evening: 18:00 - 21:59
                greeting = document.getElementById('eveningGreeting').value || defaultSettings.eveningGreeting;
            } else {
                // Night: 22:00 - 05:59
                greeting = document.getElementById('nightGreeting').value || defaultSettings.nightGreeting;
            }
            
            // Add custom message if provided
            const customMessage = document.getElementById('greetingCustomMessage').value;
            if (customMessage && customMessage.trim()) {
                greeting += ', ' + customMessage.trim();
            }
            
            return greeting;
        }

        // Sleep the bot
        function sleepBot(input) {
            isAwake = false;
            
            if (awakeTimeout) {
                clearTimeout(awakeTimeout);
            }
            
            addMessage('user', input);
            
            // Use customizable sleep responses
            const response = sleepResponses[Math.floor(Math.random() * sleepResponses.length)];
            addMessage('bot', response);
            
            // Speak the sleep response
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
                
                // Ensure voices are loaded before proceeding
                const speakSleepResponse = () => {
                    const utterance = new SpeechSynthesisUtterance(response);
                    
                    // Apply voice settings - enhanced voice selection
                    const voiceSelect = document.getElementById('botVoice').value;
                    const speedSelect = document.getElementById('botSpeed').value;
                    const pitchSelect = document.getElementById('botPitch').value;
                    
                    const voices = speechSynthesis.getVoices();
                    let selectedVoice = null;
                    
                    // First try to find exact match
                    selectedVoice = voices.find(voice => voice.name === voiceSelect);
                    
                    // If not found, try partial match
                    if (!selectedVoice) {
                        const voiceParts = voiceSelect.split('-');
                        if (voiceParts.length >= 3) {
                            const voiceName = voiceParts[2].replace('Neural', '');
                            selectedVoice = voices.find(voice => 
                                voice.name.toLowerCase().includes(voiceName.toLowerCase()) &&
                                voice.lang.includes(voiceParts[0] + '-' + voiceParts[1])
                            );
                        }
                    }
                    
                    // If still not found, try any voice with similar language
                    if (!selectedVoice && voiceSelect.includes('-')) {
                        const lang = voiceSelect.substring(0, 5); // e.g., "en-US"
                        selectedVoice = voices.find(voice => voice.lang === lang);
                    }
                    
                    if (selectedVoice) {
                        utterance.voice = selectedVoice;
                        console.log('Sleep - Using voice:', selectedVoice.name);
                    } else {
                        console.log('Sleep - Voice not found, using default. Requested:', voiceSelect);
                        console.log('Available voices:', voices.map(v => v.name));
                    }
                    
                    // Set speech parameters
                    switch(speedSelect) {
                        case 'x-slow': utterance.rate = 0.5; break;
                        case 'slow': utterance.rate = 0.75; break;
                        case 'medium': utterance.rate = 1.0; break;
                        case 'fast': utterance.rate = 1.25; break;
                        case 'x-fast': utterance.rate = 1.5; break;
                    }
                    
                    // Set pitch
                    const pitchValue = parseFloat(pitchSelect);
                    utterance.pitch = pitchValue;
                    
                    speechSynthesis.speak(utterance);
                };
                
                // Check if voices are already loaded
                if (speechSynthesis.getVoices().length > 0) {
                    speakSleepResponse();
                } else {
                    // Wait for voices to load
                    speechSynthesis.addEventListener('voiceschanged', speakSleepResponse, { once: true });
                    // Fallback timeout in case voiceschanged doesn't fire
                    setTimeout(speakSleepResponse, 100);
                }
            }
            
            // Update last interaction time and reset absence greeting flag
            lastInteractionTime = new Date().getTime();
            localStorage.setItem('lastInteractionTime', lastInteractionTime.toString());
            absenceGreetingGiven = false; // Reset for next wake up after sufficient absence
            
            updateBotAvatar('idle', 'üò¥');
            updateStatus('üò¥ Assistant Sleeping', 'Say a wake word to wake me up again');
        }

        // Interrupt the bot - stops all speech and AI processing immediately
        function interruptBot(input) {
            console.log('Interrupting bot with input:', input);
            
            // Stop any ongoing speech immediately and forcefully
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
                console.log('Cancelled ongoing speech synthesis');
            }
            
            // Cancel the current utterance if it exists
            if (currentUtterance) {
                currentUtterance.onend = null; // Remove the onend handler to prevent resume
                currentUtterance = null;
                console.log('Cancelled current utterance');
            }
            
            // Force stop speaking flag and clear speech tracking
            isSpeaking = false;
            botSpeechStartTime = 0;
            botSpeechEndTime = Date.now();
            lastSpokenText = '';
            console.log('Force stopped speaking flag and cleared speech tracking');
            
            // Cancel any ongoing AI requests (if possible)
            // Note: We can't easily cancel fetch requests mid-flight, but we can ignore their responses
            
            // Add the interrupt command to chat
            addMessage('user', input);
            
            // Quick acknowledgment
            const interruptResponses = [
                "Stopped",
                "Quiet",
                "Interrupted", 
                "Paused",
                "Halted"
            ];
            
            const response = interruptResponses[Math.floor(Math.random() * interruptResponses.length)];
            addMessage('bot', response);
            
            // Update avatar and status
            updateBotAvatar('idle', 'üõë');
            updateStatus('üõë Interrupted', 'Speech and processing stopped');
            
            // Make sure speech recognition is still running for future commands
            if (isBotActive && !isListening) {
                try {
                    console.log('Restarting speech recognition after interrupt');
                    speechRecognition.start();
                    isListening = true;
                } catch (error) {
                    console.log('Error restarting speech recognition:', error);
                }
            }
            
            // Reset to normal listening state after a moment
            setTimeout(() => {
                if (isAwake && isBotActive) {
                    updateBotAvatar('listening', 'üëÇ');
                    updateStatus('üéôÔ∏è Listening', 'Ready for your next command');
                }
            }, 1000);
            
            // Reset sleep timer if awake
            if (isAwake) {
                resetSleepTimer();
            }
        }

        // Handle input when bot is awake
        async function handleAwakeInput(input) {
            addMessage('user', input);
            
            // Check for reminder input first (highest priority during reminder flow)
            if (handleReminderInput(input)) {
                return; // Reminder system handled the input
            }
            
            // Check for settings phrase
            const openSettingsPhrase = document.getElementById('openSettingsPhrase').value || defaultSettings.openSettingsPhrase;
            if (input.toLowerCase().includes(openSettingsPhrase.toLowerCase())) {
                openSettingsPanel();
                respondToUser("Opening settings panel for you.");
                return;
            }
            
            // Check if we should use Ollama first
            const useOllama = document.getElementById('useOllama').checked;
            let shouldUseAI = false;
            
            // Check if this matches any user commands first
            const lowerInput = input.toLowerCase();
            let foundCommand = false;
            for (const [command, responses] of Object.entries(userCommands)) {
                if (lowerInput.includes(command.toLowerCase())) {
                    foundCommand = true;
                    break;
                }
            }
            
            // If no command found and Ollama is enabled, use AI
            if (!foundCommand && useOllama) {
                shouldUseAI = true;
                
                // Show thinking message in chat only
                addMessage('bot', 'AI is thinking...');
                updateBotAvatar('processing', 'ü§î');
                updateStatus('üß† AI Thinking...', 'Asking Ollama for an intelligent response');
            }
            
            // Get the response
            const response = await generateAdvancedResponse(input);
            
            // If we were using AI, remove the "thinking" message
            if (shouldUseAI) {
                // Remove the last message (the "AI is thinking..." message)
                const conversation = document.getElementById('conversation');
                const messages = conversation.children;
                if (messages.length > 0) {
                    const lastMessage = messages[messages.length - 1];
                    if (lastMessage.textContent.includes('AI is thinking...')) {
                        conversation.removeChild(lastMessage);
                    }
                }
            }
            
            // Now respond normally
            respondToUser(response);
            
            // Reset sleep timer
            resetSleepTimer();
        }

        // Enhanced response generation - now uses user-defined commands or Ollama
        async function generateAdvancedResponse(input) {
            const lowerInput = input.toLowerCase();

            // Check for special dynamic commands first
            if (lowerInput.includes('time')) {
                const currentTime = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const timeFormat = document.getElementById('timeResponseFormat').value || defaultSettings.timeResponseFormat;
                return timeFormat.replace('{time}', currentTime);
            }
            
            if (lowerInput.includes('date')) {
                const currentDate = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                const dateFormat = document.getElementById('dateResponseFormat').value || defaultSettings.dateResponseFormat;
                return dateFormat.replace('{date}', currentDate);
            }
            
            if (lowerInput.includes('look at me')) {
                openCameraView();
                return "Looking at you now! I can see you through the camera.";
            }
            
            if (lowerInput.includes('stop looking') || lowerInput.includes('close camera') || lowerInput.includes('turn off camera')) {
                if (isCameraActive) {
                    closeCameraView();
                    return "I've stopped looking. Camera is now off.";
                } else {
                    return "I'm not currently looking. Say 'look at me' to activate the camera.";
                }
            }
            
            if (lowerInput.includes('how many people') || lowerInput.includes('how many person') || lowerInput.includes('people do you see') || lowerInput.includes('detect people')) {
                if (isCameraActive) {
                    const result = await detectPeople();
                    return result;
                } else {
                    return "I need to see you first. Say 'look at me' to open the camera, then ask me to count people.";
                }
            }
            
            if (lowerInput.includes('check for motion') || lowerInput.includes('start motion detection') || lowerInput.includes('monitor motion')) {
                if (isCameraActive) {
                    startMotionDetection();
                    return "Motion detection started! I'm now in monitoring mode and will only listen for 'don't detect motion' to stop.";
                } else {
                    return "I need to see you first. Say 'look at me' to open the camera, then ask me to check for motion.";
                }
            }
            
            if (lowerInput.includes('turn off detection') || lowerInput.includes('stop motion detection') || lowerInput.includes('disable motion')) {
                stopMotionDetection();
                return "Motion detection stopped. I'm no longer monitoring for movement.";
            }
            
            // Smart View commands
            if (lowerInput.includes('open smart view') || lowerInput.includes('open smart ui') || lowerInput.includes('start smart view')) {
                openSmartView();
                return "Opening Smart Hand Tracking View! Use hand gestures to interact with images. Press 'i' to import images or say 'close smart view' to exit.";
            }
            
            if (lowerInput.includes('close smart view') || lowerInput.includes('exit smart view') || lowerInput.includes('close smart ui')) {
                closeSmartView();
                return "Smart View closed. Back to our conversation!";
            }

            // Spotify music commands
            if (document.getElementById('useSpotify').checked && spotifyAccessToken) {
                if (lowerInput.includes('play music') || lowerInput.includes('play song') || lowerInput.includes('start music')) {
                    // Extract what to play from the command
                    let query = '';
                    const playPatterns = [
                        /play (?:music|song|track)? ?(?:by|from)? (.+)/i,
                        /play (.+)/i
                    ];
                    
                    for (const pattern of playPatterns) {
                        const match = input.match(pattern);
                        if (match && match[1]) {
                            query = match[1].replace(/^(?:music|song|track|by|from) ?/i, '').trim();
                            break;
                        }
                    }
                    
                    return await playSpotifyMusic(query);
                }
                
                if (lowerInput.includes('pause music') || lowerInput.includes('pause song') || lowerInput.includes('stop music') || lowerInput.includes('stop playing')) {
                    return await pauseSpotifyMusic();
                }
                
                if (lowerInput.includes('skip') || lowerInput.includes('next song') || lowerInput.includes('next track')) {
                    return await skipSpotifyTrack();
                }
                
                if (lowerInput.includes('previous') || lowerInput.includes('last song') || lowerInput.includes('go back')) {
                    return await previousSpotifyTrack();
                }
                
                if (lowerInput.includes('volume') || lowerInput.includes('turn up') || lowerInput.includes('turn down')) {
                    let volume = 50; // default
                    
                    // Extract volume level from command
                    const volumeMatch = input.match(/(?:volume|set volume) (?:to )?(\d+)/i);
                    if (volumeMatch) {
                        volume = parseInt(volumeMatch[1]);
                    } else if (lowerInput.includes('turn up') || lowerInput.includes('louder')) {
                        volume = 80;
                    } else if (lowerInput.includes('turn down') || lowerInput.includes('lower') || lowerInput.includes('quieter')) {
                        volume = 30;
                    } else if (lowerInput.includes('max') || lowerInput.includes('maximum')) {
                        volume = 100;
                    } else if (lowerInput.includes('min') || lowerInput.includes('minimum') || lowerInput.includes('mute')) {
                        volume = 0;
                    }
                    
                    return await setSpotifyVolume(volume);
                }
                
                if (lowerInput.includes('what\'s playing') || lowerInput.includes('current song') || lowerInput.includes('now playing')) {
                    return await getCurrentSpotifyTrack();
                }
            }

            // Check user-defined commands
            for (const [command, responses] of Object.entries(userCommands)) {
                // Skip time and date commands as they're handled dynamically above
                if (command.toLowerCase() === 'time' || command.toLowerCase() === 'date') {
                    continue;
                }
                if (lowerInput.includes(command.toLowerCase())) {
                    return getRandomResponse(responses);
                }
            }

            // Check if Ollama is enabled
            const useOllama = document.getElementById('useOllama').checked;
            
            if (useOllama) {
                // Use Ollama for intelligent responses
                const prompt = `You are a voice assistant. Answer naturally like you're speaking to someone. Give one simple answer, not a list. Be conversational and brief. No numbered lists, no bullet points, no formatting.

User: "${input}"`;
                
                try {
                    const aiResponse = await queryOllama(prompt);
                    return aiResponse;
                } catch (error) {
                    console.error('Ollama failed, using fallback:', error);
                    // Fall through to default response only if Ollama fails
                }
            }

            // If no command matches and Ollama is off/failed, use fallback response
            return getRandomFallbackResponse('didntUnderstand');
        }

        // Get random response from array or function
        function getRandomResponse(responses) {
            if (typeof responses === 'function') {
                responses = responses();
            }
            return responses[Math.floor(Math.random() * responses.length)];
        }

        // Respond to user with enhanced speech
        function respondToUser(text) {
            updateBotAvatar('processing', 'ü§î');
            updateStatus('ü§î Processing Your Request', 'Thinking about the best response...');
            
            addMessage('bot', text);
            responseCount++;
            updateStats();
            
            // Store the response for feedback prevention
            lastBotResponse = text;
            
            // Enhanced speech synthesis
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                const voiceSelect = document.getElementById('botVoice').value;
                const speedSelect = document.getElementById('botSpeed').value;
                const pitchSelect = document.getElementById('botPitch').value;
                
                // Try to find matching voice - improved voice selection
                const voices = speechSynthesis.getVoices();
                let selectedVoice = null;
                
                // First try to find exact match
                selectedVoice = voices.find(voice => voice.name === voiceSelect);
                
                // If not found, try partial match
                if (!selectedVoice) {
                    const voiceParts = voiceSelect.split('-');
                    if (voiceParts.length >= 3) {
                        const voiceName = voiceParts[2].replace('Neural', '');
                        selectedVoice = voices.find(voice => 
                            voice.name.toLowerCase().includes(voiceName.toLowerCase()) &&
                            voice.lang.includes(voiceParts[0] + '-' + voiceParts[1])
                        );
                    }
                }
                
                // If still not found, try any voice with similar language
                if (!selectedVoice && voiceSelect.includes('-')) {
                    const lang = voiceSelect.substring(0, 5); // e.g., "en-US"
                    selectedVoice = voices.find(voice => voice.lang === lang);
                }
                
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                    console.log('Using voice:', selectedVoice.name);
                } else {
                    console.log('Voice not found, using default. Available voices:', voices.map(v => v.name));
                }
                
                // Set speech parameters with improved pitch handling
                switch(speedSelect) {
                    case 'x-slow': utterance.rate = 0.5; break;
                    case 'slow': utterance.rate = 0.75; break;
                    case 'medium': utterance.rate = 1.0; break;
                    case 'fast': utterance.rate = 1.25; break;
                    case 'x-fast': utterance.rate = 1.5; break;
                }
                
                // Improved pitch setting - use numeric values directly
                const pitchValue = parseFloat(pitchSelect);
                utterance.pitch = pitchValue;
                console.log('Setting pitch to:', pitchValue);
                
                utterance.onstart = () => {
                    isSpeaking = true;
                    botSpeechStartTime = Date.now();
                    lastSpokenText = text.toLowerCase();
                    updateBotAvatar('speaking', 'üó£Ô∏è');
                    updateStatus('üó£Ô∏è Speaking Response', 'Delivering your personalized response');
                    console.log('Bot started speaking at:', botSpeechStartTime);
                };
                
                utterance.onend = () => {
                    isSpeaking = false;
                    botSpeechEndTime = Date.now();
                    currentUtterance = null;
                    console.log('Bot finished speaking at:', botSpeechEndTime);
                    
                    // Only resume if this utterance wasn't interrupted
                    if (utterance.onend !== null) {
                        // Use user-defined timeout
                        const timeoutValue = parseInt(document.getElementById('timeoutSelect').value);
                        setTimeout(() => {
                            resumeListeningAfterSpeech();
                        }, timeoutValue);
                    }
                };
                
                utterance.onerror = (event) => {
                    console.error('Speech synthesis error:', event.error);
                    isSpeaking = false;
                    currentUtterance = null;
                    
                    // Only resume if this utterance wasn't interrupted
                    if (utterance.onend !== null) {
                        const timeoutValue = parseInt(document.getElementById('timeoutSelect').value);
                        setTimeout(() => {
                            resumeListeningAfterSpeech();
                        }, timeoutValue);
                    }
                };
                
                speechSynthesis.speak(utterance);
                currentUtterance = utterance;
            }
        }

        // Resume listening after bot finishes speaking
        function resumeListeningAfterSpeech() {
            if (isBotActive && !isSpeaking) {
                if (!isListening) {
                    try {
                        console.log('Resuming speech recognition after bot speech');
                        speechRecognition.start();
                        isListening = true;
                    } catch (error) {
                        console.error('Error resuming speech recognition:', error);
                        // If it fails, try again with a longer delay
                        setTimeout(() => {
                            if (isBotActive && !isListening && !isSpeaking) {
                                try {
                                    speechRecognition.start();
                                    isListening = true;
                                } catch (e) {
                                    console.error('Failed to restart speech recognition:', e);
                                }
                            }
                        }, 1000);
                    }
                } else {
                    console.log('Speech recognition already running, no need to restart');
                }
                
                updateBotAvatar('listening', 'üëÇ');
                updateStatus('üëÇ Listening for Your Reply', 'Continue our conversation or let me know how else I can help');
            }
        }

        // Enhanced message display with timestamps
        function addMessage(sender, text) {
            const conversation = document.getElementById('conversation');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const timestamp = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            
            messageDiv.innerHTML = `
                <div class="message-label">${sender === 'user' ? 'You' : 'Assistant'}</div>
                ${text}
                <div class="message-time">${timestamp}</div>
            `;
            
            conversation.appendChild(messageDiv);
            conversation.scrollTop = conversation.scrollHeight;
        }

        // Update bot avatar with enhanced animations
        function updateBotAvatar(status, emoji) {
            const avatar = document.getElementById('botAvatar');
            avatar.className = `bot-avatar ${status}`;
            avatar.textContent = emoji;
            
            // Also update fullscreen avatar
            const fullscreenAvatar = document.getElementById('fullscreenAvatar');
            fullscreenAvatar.className = `fullscreen-avatar ${status}`;
            fullscreenAvatar.textContent = emoji;
        }

        // Update status with enhanced formatting
        function updateStatus(title, description) {
            const statusText = document.getElementById('statusText');
            statusText.innerHTML = `<strong style="color: #2c3e50;">${title}</strong><br><span style="color: #636e72;">${description}</span>`;
            
            // Also update fullscreen status
            document.getElementById('fullscreenStatus').textContent = title;
            document.getElementById('fullscreenSubstatus').textContent = description;
        }

        // Open fullscreen avatar view
        function openFullscreenAvatar() {
            const overlay = document.getElementById('fullscreenOverlay');
            overlay.classList.add('active');
            
            // Sync current avatar state
            const currentAvatar = document.getElementById('botAvatar');
            const fullscreenAvatar = document.getElementById('fullscreenAvatar');
            fullscreenAvatar.className = currentAvatar.className.replace('bot-avatar', 'fullscreen-avatar');
            fullscreenAvatar.textContent = currentAvatar.textContent;
        }

        // Close fullscreen avatar view
        function closeFullscreenAvatar() {
            const overlay = document.getElementById('fullscreenOverlay');
            overlay.classList.remove('active');
            
            // Also close camera if it's open
            closeCameraView();
        }
        
        // Open settings panel via voice command
        function openSettingsPanel() {
            // Close the fullscreen view to reveal the settings panel
            closeFullscreenAvatar();
        }
        
        // Open settings panel with password protection
        function openSettingsWithPassword() {
            const savedPassword = document.getElementById('settingsPassword').value || defaultSettings.settingsPassword;
            const enteredPassword = prompt('Enter settings password:');
            
            if (enteredPassword === savedPassword) {
                // Close the fullscreen view to reveal the settings panel
                closeFullscreenAvatar();
            } else if (enteredPassword !== null) {
                // User didn't cancel, but password was wrong
                alert('Incorrect password. Settings access denied.');
            }
            // If enteredPassword is null, user cancelled - do nothing
        }

        // Open camera view
        async function openCameraView() {
            if (isCameraActive) {
                console.log('Camera is already active');
                return;
            }
            
            try {
                const cameraContainer = document.getElementById('cameraContainer');
                const video = document.getElementById('cameraVideo');
                
                // Request camera access
                cameraStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 320 },
                        height: { ideal: 240 },
                        facingMode: 'user'
                    } 
                });
                
                video.srcObject = cameraStream;
                cameraContainer.style.display = 'block';
                isCameraActive = true;
                
                console.log('Camera opened successfully');
                
                // Preload detection model in background for faster detection
                loadDetectionModel().then(() => {
                    console.log('Detection model preloaded and ready');
                    const detectionInfo = document.getElementById('detectionInfo');
                    const motionBtn = document.getElementById('motionToggleBtn');
                    if (detectionInfo) {
                        detectionInfo.style.display = 'block';
                    }
                    if (motionBtn) {
                        motionBtn.style.display = 'inline-block';
                    }
                }).catch(error => {
                    console.warn('Model preloading failed:', error);
                });
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                
                // Provide more specific error messages
                let errorMessage = 'Could not access camera. ';
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Please grant camera permission and try again.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No camera device found.';
                } else if (error.name === 'NotReadableError') {
                    errorMessage += 'Camera is being used by another application.';
                } else {
                    errorMessage += 'Please make sure you have a camera connected.';
                }
                
                // Don't show alert in fullscreen mode, just log
                console.warn(errorMessage);
            }
        }

        // Close camera view
        function closeCameraView() {
            const cameraContainer = document.getElementById('cameraContainer');
            const video = document.getElementById('cameraVideo');
            
            // Stop camera stream
            if (cameraStream) {
                const tracks = cameraStream.getTracks();
                tracks.forEach(track => track.stop());
                cameraStream = null;
            }
            
            if (video.srcObject) {
                video.srcObject = null;
            }
            
            // Stop motion detection if active
            stopMotionDetection();
            
            cameraContainer.style.display = 'none';
            isCameraActive = false;
            console.log('Camera closed');
        }

        // Load human detection model
        async function loadDetectionModel() {
            if (detectionModel || isModelLoading) {
                return detectionModel;
            }
            
            try {
                isModelLoading = true;
                console.log('Loading human detection model...');
                detectionModel = await cocoSsd.load();
                console.log('Human detection model loaded successfully');
                return detectionModel;
            } catch (error) {
                console.error('Error loading detection model:', error);
                return null;
            } finally {
                isModelLoading = false;
            }
        }

        // Detect people in camera feed
        async function detectPeople() {
            if (!isCameraActive) {
                return "Camera is not active. Please say 'look at me' first.";
            }
            
            const video = document.getElementById('cameraVideo');
            if (!video || !video.videoWidth || !video.videoHeight) {
                return "Camera feed is not ready yet. Please wait a moment and try again.";
            }
            
            // Update status to show we're analyzing
            const cameraStatus = document.getElementById('cameraStatus');
            if (cameraStatus) {
                cameraStatus.textContent = "Analyzing... üîç";
            }
            
            try {
                // Load model if not already loaded
                const model = await loadDetectionModel();
                if (!model) {
                    if (cameraStatus) cameraStatus.textContent = "Looking at you üëÅÔ∏è";
                    return "Sorry, I'm having trouble loading the vision system. Please try again later.";
                }
                
                console.log('Analyzing camera feed for people...');
                
                // Perform detection
                const predictions = await model.detect(video);
                
                // Filter for people
                const people = predictions.filter(prediction => 
                    prediction.class === 'person' && prediction.score > 0.5
                );
                
                console.log('Detection results:', people);
                
                // Reset status
                if (cameraStatus) {
                    cameraStatus.textContent = "Looking at you üëÅÔ∏è";
                }
                
                // Generate response
                if (people.length === 0) {
                    return "I don't see any people in the camera view right now.";
                } else if (people.length === 1) {
                    const confidence = Math.round(people[0].score * 100);
                    return `I can see 1 person in the camera with ${confidence}% confidence.`;
                } else {
                    const avgConfidence = Math.round(
                        people.reduce((sum, person) => sum + person.score, 0) / people.length * 100
                    );
                    return `I can see ${people.length} people in the camera with an average confidence of ${avgConfidence}%.`;
                }
                
            } catch (error) {
                console.error('Error during people detection:', error);
                if (cameraStatus) cameraStatus.textContent = "Looking at you üëÅÔ∏è";
                return "Sorry, I encountered an error while analyzing the camera feed. Please try again.";
            }
        }

        // Initialize motion detection canvas
        function initMotionDetection() {
            if (!motionCanvas) {
                motionCanvas = document.createElement('canvas');
                motionContext = motionCanvas.getContext('2d');
                motionCanvas.width = 320;
                motionCanvas.height = 240;
            }
        }

        // Start motion detection
        function startMotionDetection() {
            if (motionDetectionActive || !isCameraActive) {
                return;
            }

            initMotionDetection();
            motionDetectionActive = true;
            previousFrame = null;

            // Update camera status
            const cameraStatus = document.getElementById('cameraStatus');
            if (cameraStatus) {
                cameraStatus.textContent = "Monitoring motion üîç (Limited listening)";
            }

            // Update bot status to show limited listening
            updateStatus('üîç Motion Detection Active', 'Only listening for "don\'t detect motion" command');

            // Update UI indicators
            const motionInfo = document.getElementById('motionInfo');
            const motionBtn = document.getElementById('motionToggleBtn');
            if (motionInfo) motionInfo.style.display = 'block';
            if (motionBtn) {
                motionBtn.textContent = '‚èπÔ∏è Stop Motion Detection';
                motionBtn.style.background = 'linear-gradient(135deg, #fd79a8, #e84393)';
            }

            // Start motion detection loop
            motionDetectionInterval = setInterval(() => {
                if (!motionDetectionActive || !isCameraActive) {
                    stopMotionDetection();
                    return;
                }
                checkForMotion();
            }, 500); // Check every 500ms

            console.log('Motion detection started');
            
            // Inform user about limited listening mode
            speak("Motion detection started. I'm now only listening for 'don't detect motion' to stop monitoring.");
        }

        // Stop motion detection
        function stopMotionDetection() {
            motionDetectionActive = false;
            
            if (motionDetectionInterval) {
                clearInterval(motionDetectionInterval);
                motionDetectionInterval = null;
            }

            previousFrame = null;

            // Update camera status
            const cameraStatus = document.getElementById('cameraStatus');
            if (cameraStatus && isCameraActive) {
                cameraStatus.textContent = "Looking at you üëÅÔ∏è";
            }

            // Restore normal bot status
            if (isBotActive) {
                updateBotAvatar('listening', 'üëÇ');
                updateStatus('üéôÔ∏è Listening for Commands', 'Ready for all voice commands and conversations');
            }

            // Update UI indicators
            const motionInfo = document.getElementById('motionInfo');
            const motionBtn = document.getElementById('motionToggleBtn');
            if (motionInfo) motionInfo.style.display = 'none';
            if (motionBtn) {
                motionBtn.textContent = 'üéØ Start Motion Detection';
                motionBtn.style.background = 'linear-gradient(135deg, #00b894, #00cec9)';
            }

            console.log('Motion detection stopped');
        }

        // Toggle motion detection (for UI button)
        function toggleMotionDetection() {
            if (motionDetectionActive) {
                stopMotionDetection();
            } else {
                startMotionDetection();
            }
        }

        // Check for motion in camera feed
        function checkForMotion() {
            if (!motionDetectionActive || !isCameraActive) {
                return;
            }

            const video = document.getElementById('cameraVideo');
            if (!video || !video.videoWidth || !video.videoHeight) {
                return;
            }

            try {
                // Draw current frame to canvas
                motionContext.drawImage(video, 0, 0, motionCanvas.width, motionCanvas.height);
                const currentFrame = motionContext.getImageData(0, 0, motionCanvas.width, motionCanvas.height);

                if (previousFrame) {
                    // Calculate difference between frames
                    const motionLevel = calculateMotionLevel(previousFrame, currentFrame);
                    
                    // Motion threshold (adjust as needed)
                    const motionThreshold = 15;
                    
                    if (motionLevel > motionThreshold) {
                        console.log('Motion detected! Level:', motionLevel);
                        announceMotionDetected(motionLevel);
                    }
                }

                // Store current frame for next comparison
                previousFrame = currentFrame;

            } catch (error) {
                console.error('Error during motion detection:', error);
            }
        }

        // Calculate motion level between two frames
        function calculateMotionLevel(frame1, frame2) {
            let motionPixels = 0;
            const pixelThreshold = 30; // Sensitivity threshold for pixel change
            
            for (let i = 0; i < frame1.data.length; i += 4) {
                // Calculate brightness difference for each pixel
                const brightness1 = (frame1.data[i] + frame1.data[i + 1] + frame1.data[i + 2]) / 3;
                const brightness2 = (frame2.data[i] + frame2.data[i + 1] + frame2.data[i + 2]) / 3;
                
                if (Math.abs(brightness1 - brightness2) > pixelThreshold) {
                    motionPixels++;
                }
            }
            
            // Return motion level as percentage
            return (motionPixels / (frame1.data.length / 4)) * 100;
        }

        // Announce motion detection
        function announceMotionDetected(motionLevel) {
            if (!motionDetectionActive) return;
            
            const motionMessages = [
                "Motion detected!",
                "I see movement!",
                "Something is moving!",
                "Movement spotted!",
                "I detected motion!"
            ];
            
            const message = motionMessages[Math.floor(Math.random() * motionMessages.length)];
            
            // Add to chat
            addMessage('bot', message);
            
            // Speak announcement if not already speaking
            if (!isSpeaking) {
                const utterance = new SpeechSynthesisUtterance(message);
                utterance.rate = 1.2; // Speak a bit faster for alerts
                utterance.volume = 0.8;
                speechSynthesis.speak(utterance);
            }
            
            console.log(`Motion announced: ${message} (Level: ${motionLevel.toFixed(2)}%)`);
        }

        // Open Smart View
        async function openSmartView() {
            const overlay = document.getElementById('smartViewOverlay');
            const content = document.getElementById('smartViewContent');
            
            try {
                // Embed the complete smart UI content using innerHTML
                const htmlContent = '<style>' +
                    'body { background: #000; font-family: "Segoe UI", Arial, sans-serif; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; }' +
                    '.container { background: transparent; border-radius: 0; box-shadow: none; padding: 0; text-align: center; }' +
                    '#movableImage { border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.3); border: 2px solid #6e8efb; transition: border-color 0.3s, box-shadow 0.3s; }' +
                    '#imagesContainer img { will-change: left, top, transform; backface-visibility: hidden; -webkit-backface-visibility: hidden; }' +
                    '#imagesContainer img.selected { border: 4px solid #ffb300; box-shadow: 0 0 24px 8px #ffb30099; transition: border-color 0.3s, box-shadow 0.3s; }' +
                    '#progressCircle { width: 80px; height: 80px; pointer-events: none; background: transparent; z-index: 10001; }' +
                    '#overlay { border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.3); border: 2px solid #6e8efb; transition: border-color 0.3s, box-shadow 0.3s; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: transparent; margin: 0; border: none; z-index: 9999; display: block; pointer-events: none; }' +
                    '#status { position: fixed; top: 70px; left: 50%; transform: translateX(-50%); font-size: 1.2em; color: #fff; z-index: 10002; background: rgba(0, 0, 0, 0.7); padding: 10px 20px; border-radius: 20px; backdrop-filter: blur(10px); }' +
                    '</style>' +
                    '<div class="container">' +
                    '<div id="imagesContainer"></div>' +
                    '<div id="progressCircle" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); z-index:4;"></div>' +
                    '<canvas id="overlay"></canvas>' +
                    '<div id="status">Initializing...</div>' +
                    '</div>';
                
                content.innerHTML = htmlContent;
                
                // Load MediaPipe script dynamically
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
                script.onload = () => {
                    // Wait a bit more for MediaPipe to be fully ready
                    setTimeout(() => {
                        initializeCompleteSmartUI();
                    }, 1500);
                };
                script.onerror = () => {
                    document.getElementById('status').textContent = 'Failed to load MediaPipe. Please check your internet connection.';
                };
                document.head.appendChild(script);
                
                // Show the overlay
                overlay.classList.add('active');
                
                console.log('Smart View opened successfully');
                
            } catch (error) {
                console.error('Failed to load Smart View:', error);
                addMessage('bot', 'Sorry, I could not open the Smart View. There was an error initializing the interface.');
            }
        }

        // Close Smart View
        function closeSmartView() {
            const overlay = document.getElementById('smartViewOverlay');
            const content = document.getElementById('smartViewContent');
            
            // Hide the overlay
            overlay.classList.remove('active');
            
            // Clean up smart UI resources
            if (window.cleanupSmartUI) {
                window.cleanupSmartUI();
                window.cleanupSmartUI = null;
            }
            
            // Clear the content to stop any running scripts
            setTimeout(() => {
                content.innerHTML = '';
            }, 300); // Wait for transition to complete
            
            console.log('Smart View closed');
        }

        // Initialize Complete Smart UI functionality with full hand tracking
        function initializeCompleteSmartUI() {
            // Check if MediaPipe Hands is available
            if (typeof Hands === 'undefined') {
                document.getElementById('status').textContent = 'Loading MediaPipe...';
                setTimeout(() => initializeCompleteSmartUI(), 500);
                return;
            }

            // Complete Smart UI variables (exact copy from handtrack.js)
            const imagesContainer = document.getElementById('imagesContainer');
            const progressCircle = document.getElementById('progressCircle');
            let images = [];
            let selectedImage = null;
            let isPinching = false;
            let pinchHandPos = {x: 0, y: 0};
            let pinchStartTime = null;
            let rightGesture = { active: false, startAngle: 0, startRotation: 0 };
            let rightPinchScale = { active: false, startDist: 0, startScale: 1 };
            
            // Tuning constants
            const SELECTION_HOLD = 0.4;
            const UNSELECT_HOLD = 0.4;
            const PINCH_DISTANCE_THRESHOLD = 0.09;
            const SMOOTHING = 0.32;
            const ROTATION_SMOOTHING = 0.18;
            const ROTATION_DEADZONE = 0.6;
            const SCALE_SMOOTHING = 0.22;
            const SCALE_DEADZONE = 0.005;
            const OPEN_FINGER_RATIO = 0.55;
            const MIN_OPEN_THRESHOLD = 0.06;
            const MAX_OPEN_THRESHOLD = 0.22;
            
            // Middle-finger voice reaction settings
            const MIDDLE_FINGER_HOLD = 0.6;
            const MIDDLE_FINGER_COOLDOWN = 5000;
            let middleFingerHoldStart = null;
            let lastMiddleFingerTime = 0;

            // Helper: create an image element from a data URL or remote URL and add to the scene
            function createImageFromSrc(src) {
                const img = document.createElement('img');
                img.src = src;
                img.style.display = 'block';
                img.style.position = 'fixed';
                img.style.left = (window.innerWidth / 2) + 'px';
                img.style.top = (window.innerHeight / 2) + 'px';
                img.style.transform = 'translate(-50%, -50%) rotate(0deg) scale(1)';
                img.style.maxWidth = '200px';
                img.style.maxHeight = '200px';
                img.style.zIndex = '3';
                imagesContainer.appendChild(img);
                images.push({
                    el: img,
                    selected: false,
                    pinchStartTime: null,
                    displayX: window.innerWidth / 2,
                    displayY: window.innerHeight / 2,
                    scale: 1,
                    rotation: 0,
                    displayRotation: 0,
                    displayScale: 1
                });
            }

            // Hidden file input for importing images via keyboard
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files && e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    createImageFromSrc(ev.target.result);
                };
                reader.readAsDataURL(file);
                fileInput.value = '';
            });

            // Keyboard shortcut: press 'i' to import an image
            function handleKeydown(e) {
                const active = document.activeElement;
                if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;
                if (e.key && e.key.toLowerCase() === 'i') {
                    fileInput.click();
                }
            }
            document.addEventListener('keydown', handleKeydown);

            const canvas = document.getElementById('overlay');
            const ctx = canvas.getContext('2d');
            const statusDiv = document.getElementById('status');

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            let videoStream;
            let video;
            
            async function setupWebcam() {
                try {
                    videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
                    video = document.createElement('video');
                    video.srcObject = videoStream;
                    video.play();
                    await new Promise(resolve => video.onloadedmetadata = resolve);
                    statusDiv.textContent = 'Webcam ready. Loading hand tracking...';
                    onFrame();
                } catch (e) {
                    statusDiv.textContent = 'Error accessing webcam.';
                    console.error(e);
                }
            }

            // MediaPipe Hands setup
            const hands = new Hands({
                locateFile: file => 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/' + file
            });
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            hands.onResults(onResults);

            async function onFrame() {
                if (video && video.readyState === 4) {
                    await hands.send({image: video});
                }
                requestAnimationFrame(onFrame);
            }

            // Complete onResults function (full implementation)
            function onResults(results) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                isPinching = false;
                let allPinched = false;
                let pinchPos = null;
                let handLandmarks = null;
                let bothHandsOpen = false;
                let openHandsCount = 0;
                let handsDetected = 0;
                let leftHandLandmarks = null;
                let rightHandLandmarks = null;
                
                if (results.multiHandLandmarks && results.multiHandedness) {
                    for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                        const label = results.multiHandedness[i].label;
                        if (label === "Left") {
                            leftHandLandmarks = results.multiHandLandmarks[i];
                        } else if (label === "Right") {
                            rightHandLandmarks = results.multiHandLandmarks[i];
                        }
                    }
                    handLandmarks = leftHandLandmarks;
                    handsDetected = results.multiHandLandmarks.length;
                    
                    results.multiHandLandmarks.forEach(landmarks => {
                        const thumbTip = landmarks[4];
                        const tipIndices = [8, 12, 16, 20];
                        let closeCount = 0;
                        tipIndices.forEach(idx => {
                            const tip = landmarks[idx];
                            const dx = thumbTip.x - tip.x;
                            const dy = thumbTip.y - tip.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < 0.09) closeCount++;
                        });
                        
                        if (closeCount === 4) {
                            allPinched = true;
                            pinchPos = {
                                x: (1 - thumbTip.x) * canvas.width,
                                y: thumbTip.y * canvas.height
                            };
                        }
                        
                        // Check if hand is open
                        let openCount = 0;
                        const wrist = landmarks[0];
                        const middleMcp = landmarks[9] || landmarks[5];
                        const hx = wrist.x - middleMcp.x;
                        const hy = wrist.y - middleMcp.y;
                        let handSize = Math.sqrt(hx*hx + hy*hy);
                        if (!handSize || handSize <= 0) handSize = 0.12;
                        
                        let openThreshold = handSize * OPEN_FINGER_RATIO;
                        openThreshold = Math.max(MIN_OPEN_THRESHOLD, Math.min(MAX_OPEN_THRESHOLD, openThreshold));
                        
                        tipIndices.forEach(idx => {
                            const tip = landmarks[idx];
                            const dx = thumbTip.x - tip.x;
                            const dy = thumbTip.y - tip.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > openThreshold) openCount++;
                        });
                        
                        if (openCount === 4) {
                            openHandsCount++;
                        }
                    });
                    
                    if (openHandsCount === 2 && handsDetected >= 2) {
                        bothHandsOpen = true;
                        statusDiv.textContent = 'Both hands open - unselecting image...';
                    } else {
                        statusDiv.textContent = 'Hands detected!';
                    }
                    
                    // Draw hands
                    const leftPinchDetected = leftHandLandmarks ? (() => {
                        const t = leftHandLandmarks[4];
                        const i = leftHandLandmarks[8];
                        const dx = t.x - i.x;
                        const dy = t.y - i.y;
                        const distThumbIndex = Math.sqrt(dx*dx + dy*dy);
                        return distThumbIndex < PINCH_DISTANCE_THRESHOLD;
                    })() : false;
                    
                    const hideFingersUI = Boolean((selectedImage && selectedImage.selected) || (selectedImage && leftPinchDetected) || rightGesture.active || rightPinchScale.active);
                    
                    if (!hideFingersUI) {
                        results.multiHandLandmarks.forEach(landmarks => drawHand(landmarks));
                    }
                } else {
                    statusDiv.textContent = 'No hands detected.';
                }
                
                // Selection logic and movement (keeping only essential parts for brevity)
                handleImageSelection(leftHandLandmarks);
                handleImageMovement(leftHandLandmarks, bothHandsOpen);
                handleRightHandGestures(rightHandLandmarks);
                handleImageUnselection(bothHandsOpen);
            }
            
            function handleImageSelection(leftHandLandmarks) {
                let foundSelection = false;
                if (leftHandLandmarks && !selectedImage) {
                    const thumbTip = leftHandLandmarks[4];
                    const tipIndices = [8, 12, 16, 20];
                    let closeCount = 0;
                    tipIndices.forEach(idx => {
                        const tip = leftHandLandmarks[idx];
                        const dx = thumbTip.x - tip.x;
                        const dy = thumbTip.y - tip.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 0.09) closeCount++;
                    });
                    
                    let allPinchedLeft = closeCount === 4;
                    let pinchPosLeft = null;
                    if (allPinchedLeft) {
                        pinchPosLeft = {
                            x: (1 - thumbTip.x) * canvas.width,
                            y: thumbTip.y * canvas.height
                        };
                    }
                    
                    images.forEach(imgObj => {
                        if (!imgObj.selected && imgObj.el.style.display === 'block') {
                            if (allPinchedLeft && pinchPosLeft) {
                                const imgRect = imgObj.el.getBoundingClientRect();
                                if (
                                    pinchPosLeft.x >= imgRect.left && pinchPosLeft.x <= imgRect.right &&
                                    pinchPosLeft.y >= imgRect.top && pinchPosLeft.y <= imgRect.bottom
                                ) {
                                    if (!imgObj.pinchStartTime) imgObj.pinchStartTime = Date.now();
                                    
                                    const centerX = imgRect.left + imgRect.width / 2;
                                    const centerY = imgRect.top + imgRect.height / 2;
                                    progressCircle.style.display = 'block';
                                    progressCircle.style.left = centerX + 'px';
                                    progressCircle.style.top = centerY + 'px';
                                    
                                    const elapsed = (Date.now() - imgObj.pinchStartTime) / 1000;
                                    drawProgressCircle(elapsed);
                                    
                                    if (elapsed >= SELECTION_HOLD) {
                                        images.forEach(obj => {
                                            obj.selected = false;
                                            obj.el.classList.remove('selected');
                                        });
                                        imgObj.selected = true;
                                        imgObj.el.classList.add('selected');
                                        selectedImage = imgObj;
                                        selectedImage.displayRotation = selectedImage.rotation || 0;
                                        progressCircle.style.display = 'none';
                                    }
                                    foundSelection = true;
                                } else {
                                    imgObj.pinchStartTime = null;
                                }
                            } else {
                                imgObj.pinchStartTime = null;
                            }
                        }
                    });
                }
                if (!foundSelection) {
                    progressCircle.style.display = 'none';
                }
            }
            
            function handleImageMovement(leftHandLandmarks, bothHandsOpen) {
                if (selectedImage && selectedImage.selected && leftHandLandmarks && !bothHandsOpen) {
                    const thumbTip = leftHandLandmarks[4];
                    const indexTip = leftHandLandmarks[8];
                    const dx = thumbTip.x - indexTip.x;
                    const dy = thumbTip.y - indexTip.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < PINCH_DISTANCE_THRESHOLD) {
                        isPinching = true;
                        pinchHandPos.x = (1 - indexTip.x) * canvas.width;
                        pinchHandPos.y = indexTip.y * canvas.height;
                    }
                    
                    if (isPinching) {
                        const smoothing = SMOOTHING;
                        if (typeof selectedImage.displayX !== 'number' || typeof selectedImage.displayY !== 'number') {
                            selectedImage.displayX = pinchHandPos.x;
                            selectedImage.displayY = pinchHandPos.y;
                        }
                        
                        selectedImage.displayX += (pinchHandPos.x - selectedImage.displayX) * smoothing;
                        selectedImage.displayY += (pinchHandPos.y - selectedImage.displayY) * smoothing;
                        
                        if (Math.abs(selectedImage.displayX - pinchHandPos.x) < 0.5) selectedImage.displayX = pinchHandPos.x;
                        if (Math.abs(selectedImage.displayY - pinchHandPos.y) < 0.5) selectedImage.displayY = pinchHandPos.y;
                        
                        selectedImage.el.style.left = selectedImage.displayX + 'px';
                        selectedImage.el.style.top = selectedImage.displayY + 'px';
                        
                        const rot = (typeof selectedImage.displayRotation === 'number') ? selectedImage.displayRotation : ((typeof selectedImage.rotation === 'number') ? selectedImage.rotation : 0);
                        if (typeof selectedImage.displayScale !== 'number') selectedImage.displayScale = selectedImage.scale || 1;
                        
                        selectedImage.displayScale += (selectedImage.scale - selectedImage.displayScale) * SCALE_SMOOTHING;
                        if (Math.abs(selectedImage.displayScale - selectedImage.scale) < SCALE_DEADZONE) selectedImage.displayScale = selectedImage.scale;
                        
                        const sc = selectedImage.displayScale;
                        selectedImage.el.style.transform = 'translate(-50%, -50%) rotate(' + rot + 'deg) scale(' + sc + ')';
                    }
                }
            }
            
            function handleRightHandGestures(rightHandLandmarks) {
                if (selectedImage && selectedImage.selected && rightHandLandmarks) {
                    const thumbTipR = rightHandLandmarks[4];
                    const tipIndices = [8, 12, 16, 20];
                    let closeCountR = 0;
                    tipIndices.forEach(idx => {
                        const tip = rightHandLandmarks[idx];
                        const dx = thumbTipR.x - tip.x;
                        const dy = thumbTipR.y - tip.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 0.09) closeCountR++;
                    });
                    
                    const rightAllPinched = closeCountR === 4;
                    const rightIndexTip = rightHandLandmarks[8];
                    const dxTI = thumbTipR.x - rightIndexTip.x;
                    const dyTI = thumbTipR.y - rightIndexTip.y;
                    const rightThumbIndexDist = Math.sqrt(dxTI*dxTI + dyTI*dyTI);
                    const rightThumbIndexPinch = rightThumbIndexDist < PINCH_DISTANCE_THRESHOLD;
                    
                    const rightPinchPos = {
                        x: (1 - thumbTipR.x) * canvas.width,
                        y: thumbTipR.y * canvas.height
                    };
                    
                    if (rightAllPinched) {
                        // Two-hand pinch scaling
                        let leftPos = { x: selectedImage.displayX, y: selectedImage.displayY };
                        if (isPinching && typeof pinchHandPos.x === 'number') leftPos = { x: pinchHandPos.x, y: pinchHandPos.y };
                        else {
                            const rect = selectedImage.el.getBoundingClientRect();
                            leftPos = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                        }
                        
                        const dist = Math.hypot(leftPos.x - rightPinchPos.x, leftPos.y - rightPinchPos.y);
                        if (!rightPinchScale.active) {
                            rightPinchScale.active = true;
                            rightPinchScale.startDist = dist || 1;
                            rightPinchScale.startScale = selectedImage.scale || 1;
                            rightGesture.active = false;
                        } else {
                            const ratio = dist / (rightPinchScale.startDist || dist);
                            selectedImage.scale = Math.max(0.2, Math.min(5, rightPinchScale.startScale * ratio));
                            if (typeof selectedImage.displayScale !== 'number') selectedImage.displayScale = selectedImage.scale;
                            selectedImage.displayScale += (selectedImage.scale - selectedImage.displayScale) * SCALE_SMOOTHING;
                            if (Math.abs(selectedImage.displayScale - selectedImage.scale) < SCALE_DEADZONE) selectedImage.displayScale = selectedImage.scale;
                            const dispRot = (typeof selectedImage.displayRotation === 'number') ? selectedImage.displayRotation : selectedImage.rotation;
                            selectedImage.el.style.transform = 'translate(-50%, -50%) rotate(' + dispRot + 'deg) scale(' + selectedImage.displayScale + ')';
                        }
                    } else if (rightThumbIndexPinch) {
                        // Rotation with right thumb-index pinch
                        const wrist = rightHandLandmarks[0];
                        const indexMcp = rightHandLandmarks[5];
                        const dx = indexMcp.x - wrist.x;
                        const dy = indexMcp.y - wrist.y;
                        const angleRad = Math.atan2(dy, dx);
                        const angleDeg = angleRad * 180 / Math.PI;
                        
                        if (!rightGesture.active) {
                            rightGesture.active = true;
                            rightGesture.startAngle = angleDeg;
                            rightGesture.startRotation = selectedImage.rotation || 0;
                        }
                        
                        if (rightGesture.active) {
                            let delta = angleDeg - rightGesture.startAngle;
                            if (delta > 180) delta -= 360;
                            if (delta < -180) delta += 360;
                            const newRotation = rightGesture.startRotation - delta;
                            selectedImage.rotation = newRotation;
                            
                            if (typeof selectedImage.displayRotation !== 'number') selectedImage.displayRotation = selectedImage.rotation;
                            if (typeof selectedImage.displayScale !== 'number') selectedImage.displayScale = selectedImage.scale || 1;
                            
                            selectedImage.displayRotation += (selectedImage.rotation - selectedImage.displayRotation) * ROTATION_SMOOTHING;
                            if (Math.abs(selectedImage.displayRotation - selectedImage.rotation) < ROTATION_DEADZONE) selectedImage.displayRotation = selectedImage.rotation;
                            
                            selectedImage.displayScale += (selectedImage.scale - selectedImage.displayScale) * SCALE_SMOOTHING;
                            if (Math.abs(selectedImage.displayScale - selectedImage.scale) < SCALE_DEADZONE) selectedImage.displayScale = selectedImage.scale;
                            
                            selectedImage.el.style.transform = 'translate(-50%, -50%) rotate(' + selectedImage.displayRotation + 'deg) scale(' + selectedImage.displayScale + ')';
                        }
                    } else {
                        rightGesture.active = false;
                        rightPinchScale.active = false;
                    }
                } else {
                    rightGesture.active = false;
                    rightPinchScale.active = false;
                }
            }
            
            function handleImageUnselection(bothHandsOpen) {
                if (selectedImage && selectedImage.selected && bothHandsOpen) {
                    if (!selectedImage.unselectStartTime) {
                        selectedImage.unselectStartTime = Date.now();
                    }
                    
                    const elapsed = (Date.now() - selectedImage.unselectStartTime) / 1000;
                    const imgRect = selectedImage.el.getBoundingClientRect();
                    const centerX = imgRect.left + imgRect.width / 2;
                    const centerY = imgRect.top + imgRect.height / 2;
                    progressCircle.style.display = 'block';
                    progressCircle.style.left = centerX + 'px';
                    progressCircle.style.top = centerY + 'px';
                    drawProgressCircle(elapsed);
                    
                    if (elapsed >= UNSELECT_HOLD) {
                        selectedImage.selected = false;
                        selectedImage.el.classList.remove('selected');
                        selectedImage.unselectStartTime = null;
                        selectedImage = null;
                        progressCircle.style.display = 'none';
                    }
                } else if (selectedImage && selectedImage.selected) {
                    selectedImage.unselectStartTime = null;
                }
            }
            
            function drawProgressCircle(progress) {
                const size = 80;
                progressCircle.innerHTML = '';
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', size);
                svg.setAttribute('height', size);
                
                const circleBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circleBg.setAttribute('cx', size/2);
                circleBg.setAttribute('cy', size/2);
                circleBg.setAttribute('r', size/2 - 8);
                circleBg.setAttribute('stroke', '#fff');
                circleBg.setAttribute('stroke-width', '8');
                circleBg.setAttribute('fill', 'none');
                svg.appendChild(circleBg);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', size/2);
                circle.setAttribute('cy', size/2);
                circle.setAttribute('r', size/2 - 8);
                circle.setAttribute('stroke', '#ffb300');
                circle.setAttribute('stroke-width', '8');
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke-dasharray', 2 * Math.PI * (size/2 - 8));
                circle.setAttribute('stroke-dashoffset', (1-progress) * 2 * Math.PI * (size/2 - 8));
                circle.setAttribute('transform', 'rotate(-90 ' + (size/2) + ' ' + (size/2) + ')');
                svg.appendChild(circle);
                
                progressCircle.appendChild(svg);
            }
            
            function drawHand(landmarks) {
                const fingertipIndices = [4, 8, 12, 16, 20];
                ctx.lineWidth = Math.max(2, canvas.width * 0.0025);
                ctx.lineCap = 'round';
                
                fingertipIndices.forEach(idx => {
                    const tip = landmarks[idx];
                    const pip = landmarks[Math.max(0, idx - 2)];
                    const tx = (1 - tip.x) * canvas.width;
                    const ty = tip.y * canvas.height;
                    const px = (1 - pip.x) * canvas.width;
                    const py = pip.y * canvas.height;
                    
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
                    ctx.moveTo(px, py);
                    ctx.lineTo(tx, ty);
                    ctx.stroke();
                    ctx.closePath();
                });
                
                fingertipIndices.forEach((i, idx) => {
                    const point = landmarks[i];
                    const x = (1 - point.x) * canvas.width;
                    const y = point.y * canvas.height;
                    const baseR = Math.max(10, canvas.width * 0.012);
                    const outerR = baseR * 1.9;
                    
                    const grad = ctx.createRadialGradient(x, y, baseR * 0.2, x, y, outerR);
                    if (idx % 2 === 0) {
                        grad.addColorStop(0, 'rgba(255,210,120,0.95)');
                        grad.addColorStop(0.6, 'rgba(200,120,255,0.25)');
                        grad.addColorStop(1, 'rgba(120,80,200,0.0)');
                    } else {
                        grad.addColorStop(0, 'rgba(120,200,255,0.95)');
                        grad.addColorStop(0.6, 'rgba(180,120,255,0.25)');
                        grad.addColorStop(1, 'rgba(140,80,200,0.0)');
                    }
                    
                    ctx.beginPath();
                    ctx.fillStyle = grad;
                    ctx.arc(x, y, outerR, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(255,255,255,0.95)';
                    ctx.arc(x, y, baseR * 0.45, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
                    ctx.lineWidth = Math.max(2, canvas.width * 0.003);
                    ctx.arc(x, y, baseR * 0.9, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.closePath();
                });
            }

            // Start webcam and hand tracking
            setupWebcam();
            
            // Store cleanup function
            window.cleanupSmartUI = function() {
                document.removeEventListener('keydown', handleKeydown);
                window.removeEventListener('resize', resizeCanvas);
                if (fileInput.parentNode) {
                    fileInput.parentNode.removeChild(fileInput);
                }
                if (videoStream) {
                    videoStream.getTracks().forEach(track => track.stop());
                }
            };
        }

        // Reset sleep timer
        function resetSleepTimer() {
            if (awakeTimeout) {
                clearTimeout(awakeTimeout);
            }
            
            // Check if auto-sleep is disabled for mobile
            const isMobile = detectMobileDevice();
            const autoSleepDisabled = document.getElementById('disableMobileAutoSleep').checked;
            
            if (isMobile && mobileOptimizationEnabled && autoSleepDisabled) {
                console.log('Auto-sleep disabled for mobile - keeping assistant awake');
                return; // Don't set sleep timer on mobile if disabled
            }
            
            awakeTimeout = setTimeout(() => {
                if (isAwake) {
                    isAwake = false;
                    updateBotAvatar('listening', 'üëÇ');
                    updateStatus('üí§ Going Back to Sleep', 'Say a wake word to continue our conversation');
                    addMessage('bot', "I'm going back to sleep mode. Say a wake word when you'd like to chat again!");
                }
            }, 45000); // 45 seconds awake time
        }

        // Update statistics
        function updateStats() {
            document.getElementById('conversationCount').textContent = conversationCount;
            document.getElementById('responseCount').textContent = responseCount;
        }

        // Start the bot
        async function startBot() {
            if (!await initBot()) {
                return;
            }

            isBotActive = true;
            isAwake = false;
            
            const isMobile = detectMobileDevice();
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            try {
                // On mobile, only use push-to-talk - no continuous listening
                if (isMobile && mobileOptimizationEnabled) {
                    updateStatus('üé§ Push-to-Talk Ready', 'Hold the "Hold to Talk" button and speak');
                    addMessage('bot', "I'm now active in push-to-talk mode! Hold the 'Hold to Talk' button and speak when you want to interact with me.");
                } else {
                    // Desktop/non-mobile: use continuous listening
                    speechRecognition.start();
                    addMessage('bot', "I'm now active and continuously listening! Say one of my wake words ('Hey Bot', 'Hello Bot', 'Assistant', or 'Computer') followed by your command or question. I'm ready to help!");
                }
            } catch (error) {
                console.error('Failed to start speech recognition:', error);
                updateStatus('‚ùå Failed to Start', 'Please check microphone permissions and try again');
                stopBot();
            }
        }

        // Stop the bot
        function stopBot() {
            isBotActive = false;
            isAwake = false;
            isSpeaking = false;
            lastBotResponse = '';
            botSpeechStartTime = 0;
            reminderState = 'none'; // Reset reminder state
            pendingReminder = null; // Clear pending reminder
            
            if (awakeTimeout) {
                clearTimeout(awakeTimeout);
            }
            
            if (speechTimeout) {
                clearTimeout(speechTimeout);
            }
            
            if (restartTimeout) {
                clearTimeout(restartTimeout);
                restartTimeout = null;
            }
            
            if (silenceTimeout) {
                clearTimeout(silenceTimeout);
                silenceTimeout = null;
            }
            
            if (speechRecognition) {
                speechRecognition.abort();
                speechRecognition = null;
            }
            
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            
            // Clean up mobile optimization resources
            if (voiceActivityDetector) {
                voiceActivityDetector = null;
            }
            
            if (microphoneStream) {
                microphoneStream.getTracks().forEach(track => track.stop());
                microphoneStream = null;
            }
            
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close().catch(console.error);
                audioContext = null;
            }
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            updateBotAvatar('idle', 'ü§ñ');
            updateStatus('üõë Assistant Deactivated', 'Click "Activate Assistant" to start voice interaction again');
            
            addMessage('bot', "I've been deactivated. Thanks for chatting with me! Click 'Activate Assistant' whenever you'd like to talk again.");
        }

        // Push-to-talk functionality for mobile
        let isPushToTalkActive = false;
        let pushToTalkRecognition = null;

        function startPushToTalk(event) {
            event.preventDefault();
            console.log('Push-to-talk started - button pressed');
            
            if (isPushToTalkActive || !isBotActive) {
                console.log('Push-to-talk blocked:', { isPushToTalkActive, isBotActive });
                return;
            }
            
            // Check if speech recognition is available
            if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
                console.error('Speech recognition not supported');
                addMessage('bot', 'Speech recognition is not supported on this device.');
                return;
            }
            
            isPushToTalkActive = true;
            const pushToTalkBtn = document.getElementById('pushToTalkBtn');
            pushToTalkBtn.style.backgroundColor = '#ff4757';
            pushToTalkBtn.textContent = 'üé§ Listening...';
            
            console.log('Creating push-to-talk speech recognition...');
            
            // Create new speech recognition instance for push-to-talk
            pushToTalkRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            pushToTalkRecognition.continuous = false;
            pushToTalkRecognition.interimResults = true; // Enable interim results for better feedback
            pushToTalkRecognition.lang = 'en-US';
            pushToTalkRecognition.maxAlternatives = 1;

            pushToTalkRecognition.onstart = function() {
                updateStatus('üé§ Listening...', 'Speak now - release button when done');
                updateBotAvatar('listening', 'üéß');
            };

            pushToTalkRecognition.onresult = function(event) {
                console.log('Push-to-talk results received:', event.results);
                const result = event.results[0];
                if (result.isFinal) {
                    const text = result.transcript.trim();
                    console.log('Final transcript:', text);
                    if (text) {
                        addMessage('user', text);
                        
                        // In push-to-talk mode, we bypass wake words and process directly
                        // First check for sleep words
                        const containsSleepWord = sleepWords.some(word => text.includes(word));
                        if (containsSleepWord) {
                            sleepBot(text);
                        } else {
                            // Set awake and process the input directly
                            isAwake = true;
                            conversationCount++;
                            updateStats();
                            resetSleepTimer();
                            handleAwakeInput(text);
                        }
                        
                        // Reset UI after processing
                        setTimeout(() => {
                            updateStatus('üéØ Ready', 'Hold the "Hold to Talk" button and speak');
                            updateBotAvatar('idle', 'ü§ñ');
                        }, 500);
                    } else {
                        console.log('No text received from speech recognition');
                        addMessage('bot', "I didn't catch that. Please try again.");
                        // Reset UI if no text
                        setTimeout(() => {
                            updateStatus('üéØ Ready', 'Hold the "Hold to Talk" button and speak');
                            updateBotAvatar('idle', 'ü§ñ');
                        }, 500);
                    }
                } else {
                    console.log('Interim result:', result.transcript);
                }
            };

            pushToTalkRecognition.onerror = function(event) {
                console.error('Push-to-talk speech recognition error:', event.error);
                console.error('Error details:', event);
                addMessage('bot', `Speech recognition error: ${event.error}. Please try again.`);
                stopPushToTalk();
            };

            pushToTalkRecognition.onend = function() {
                console.log('Push-to-talk speech recognition ended');
                // Clear the recognition reference since it's done
                setTimeout(() => {
                    if (pushToTalkRecognition) {
                        pushToTalkRecognition = null;
                    }
                }, 100);
            };

            try {
                pushToTalkRecognition.start();
            } catch (error) {
                console.error('Failed to start push-to-talk:', error);
                stopPushToTalk();
            }
        }

        function stopPushToTalk(event) {
            if (event) {
                event.preventDefault();
            }
            
            console.log('Push-to-talk stopped - button released');
            
            if (!isPushToTalkActive) {
                console.log('Push-to-talk already inactive');
                return;
            }
            
            isPushToTalkActive = false;
            const pushToTalkBtn = document.getElementById('pushToTalkBtn');
            pushToTalkBtn.style.backgroundColor = '';
            pushToTalkBtn.textContent = 'üé§ Hold to Talk';
            
            if (pushToTalkRecognition) {
                console.log('Stopping push-to-talk recognition...');
                // Use stop() instead of abort() to allow final results to process
                pushToTalkRecognition.stop();
                
                // Don't immediately reset UI - let onresult handle it
                // Only reset if no result comes in within 2 seconds
                setTimeout(() => {
                    if (pushToTalkRecognition) {
                        console.log('Cleaning up push-to-talk recognition after timeout');
                        pushToTalkRecognition = null;
                        updateStatus('üéØ Ready', 'Hold the "Hold to Talk" button and speak');
                        updateBotAvatar('idle', 'ü§ñ');
                    }
                }, 2000);
            } else {
                // No recognition was active, reset UI immediately
                updateStatus('üéØ Ready', 'Hold the "Hold to Talk" button and speak');
                updateBotAvatar('idle', 'ü§ñ');
            }
        }

        // Test voice function
        function testVoice() {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            
            const testText = "Hello! This is how I sound with the selected voice.";
            const utterance = new SpeechSynthesisUtterance(testText);
            const voiceSelect = document.getElementById('botVoice').value;
            const speedSelect = document.getElementById('botSpeed').value;
            const pitchSelect = document.getElementById('botPitch').value;
            
            // Apply voice selection logic
            const voices = speechSynthesis.getVoices();
            let selectedVoice = null;
            
            selectedVoice = voices.find(voice => voice.name === voiceSelect);
            
            if (!selectedVoice) {
                const voiceParts = voiceSelect.split('-');
                if (voiceParts.length >= 3) {
                    const voiceName = voiceParts[2].replace('Neural', '');
                    selectedVoice = voices.find(voice => 
                        voice.name.toLowerCase().includes(voiceName.toLowerCase()) &&
                        voice.lang.includes(voiceParts[0] + '-' + voiceParts[1])
                    );
                }
            }
            
            if (!selectedVoice && voiceSelect.includes('-')) {
                const lang = voiceSelect.substring(0, 5);
                selectedVoice = voices.find(voice => voice.lang === lang);
            }
            
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            
            // Apply speed and pitch settings with improved pitch handling
            switch(speedSelect) {
                case 'x-slow': utterance.rate = 0.5; break;
                case 'slow': utterance.rate = 0.75; break;
                case 'medium': utterance.rate = 1.0; break;
                case 'fast': utterance.rate = 1.25; break;
                case 'x-fast': utterance.rate = 1.5; break;
            }
            
            // Improved pitch setting for test function
            const pitchValue = parseFloat(pitchSelect);
            utterance.pitch = pitchValue;
            console.log('Test voice pitch set to:', pitchValue);
            
            utterance.onstart = () => {
                console.log('Test speech started with voice:', selectedVoice?.name || 'default', 'pitch:', pitchValue);
            };
            
            speechSynthesis.speak(utterance);
            
            // Auto-save settings after voice test
            saveSettings();
        }

        // Update wake and sleep words from user input
        function updateWakeWords() {
            const wakeInput = document.getElementById('wakeWordInput').value.trim();
            const sleepInput = document.getElementById('sleepWordInput').value.trim();
            const interruptInput = document.getElementById('interruptWordInput').value.trim();
            
            if (!wakeInput && !sleepInput && !interruptInput) {
                alert('Please enter at least one wake word, sleep word, or interrupt word.');
                return;
            }
            
            // Update wake words if provided
            if (wakeInput) {
                wakeWords = wakeInput.split(',').map(word => word.trim().toLowerCase()).filter(word => word.length > 0);
            }
            
            // Update sleep words if provided
            if (sleepInput) {
                sleepWords = sleepInput.split(',').map(word => word.trim().toLowerCase()).filter(word => word.length > 0);
            }
            
            // Update interrupt words if provided
            if (interruptInput) {
                interruptWords = interruptInput.split(',').map(word => word.trim().toLowerCase()).filter(word => word.length > 0);
            }
            
            // Update displays
            updateWakeWordsDisplay();
            updateIndividualWordsDisplay();
            
            // Auto-save settings
            saveSettings();
            
            alert('Wake, sleep, and interrupt words updated successfully!');
        }

        // Reset wake, sleep, and interrupt words to defaults
        function resetWakeWords() {
            if (confirm('Reset wake, sleep, and interrupt words to defaults?')) {
                wakeWords = ['hey bot', 'hello bot', 'assistant', 'computer'];
                sleepWords = ['sleep', 'go to sleep', 'sleep mode', 'rest', 'standby'];
                interruptWords = ['stop', 'stop speaking', 'be quiet', 'shut up', 'halt', 'interrupt', 'pause', 'cancel'];
                
                // Update input fields
                document.getElementById('wakeWordInput').value = wakeWords.join(', ');
                document.getElementById('sleepWordInput').value = sleepWords.join(', ');
                document.getElementById('interruptWordInput').value = interruptWords.join(', ');
                
                // Update displays
                updateWakeWordsDisplay();
                updateIndividualWordsDisplay();
                
                alert('Wake, sleep, and interrupt words reset to defaults.');
            }
        }

        // Update wake words display
        function updateWakeWordsDisplay() {
            document.getElementById('wakeWordsList').textContent = wakeWords.join(', ');
            document.getElementById('sleepWordsList').textContent = sleepWords.join(', ');
            document.getElementById('interruptWordsList').textContent = interruptWords.join(', ');
            
            // Update individual displays
            updateIndividualWordsDisplay();
        }
        
        // Update individual words display
        function updateIndividualWordsDisplay() {
            updateWordTypeDisplay('wake', wakeWords, 'wakeWordsDisplay');
            updateWordTypeDisplay('sleep', sleepWords, 'sleepWordsDisplay');
            updateWordTypeDisplay('interrupt', interruptWords, 'interruptWordsDisplay');
        }
        
        // Update display for a specific word type
        function updateWordTypeDisplay(type, words, displayId) {
            const display = document.getElementById(displayId);
            if (!display) return;
            
            display.innerHTML = '';
            
            if (words.length === 0) {
                display.innerHTML = '<em style="color: #999;">No words added yet</em>';
                return;
            }
            
            words.forEach((word, index) => {
                const wordDiv = document.createElement('div');
                wordDiv.style.marginBottom = '5px';
                wordDiv.style.padding = '5px';
                wordDiv.style.background = '#f8f9fa';
                wordDiv.style.borderRadius = '5px';
                wordDiv.style.border = '1px solid #e9ecef';
                
                wordDiv.innerHTML = `
                    <span>${word}</span>
                    <button onclick="editWord('${type}', ${index})" style="float: right; background: #3498db; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px; margin-left: 4px;">‚úèÔ∏è</button>
                    <button onclick="removeWord('${type}', ${index})" style="float: right; background: #e74c3c; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px;">‚úï</button>
                `;
                
                display.appendChild(wordDiv);
            });
            
            // Add "Add New" button
            const addDiv = document.createElement('div');
            addDiv.style.marginTop = '10px';
            addDiv.innerHTML = `<button onclick="addNewWord('${type}')" style="width: 100%; padding: 8px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">+ Add New ${type.charAt(0).toUpperCase() + type.slice(1)} Word</button>`;
            display.appendChild(addDiv);
        }
        
        // Remove a word
        function removeWord(type, index) {
            const typeMap = {
                'wake': wakeWords,
                'sleep': sleepWords,
                'interrupt': interruptWords
            };
            
            const words = typeMap[type];
            if (!words || index < 0 || index >= words.length) return;
            
            if (confirm(`Remove "${words[index]}" from ${type} words?`)) {
                words.splice(index, 1);
                updateWakeWordsDisplay();
                saveSettings();
            }
        }
        
        // Edit a word
        function editWord(type, index) {
            const typeMap = {
                'wake': wakeWords,
                'sleep': sleepWords,
                'interrupt': interruptWords
            };
            
            const words = typeMap[type];
            if (!words || index < 0 || index >= words.length) return;
            
            const currentWord = words[index];
            const newWord = prompt(`Edit ${type} word:`, currentWord);
            
            if (newWord === null || newWord.trim() === '') {
                return; // User cancelled or entered empty text
            }
            
            const trimmedWord = newWord.trim().toLowerCase();
            
            // Check if the word already exists (and it's different from the current one)
            if (trimmedWord !== currentWord.toLowerCase() && words.some(w => w.toLowerCase() === trimmedWord)) {
                alert('This word already exists in the list.');
                return;
            }
            
            words[index] = trimmedWord;
            updateWakeWordsDisplay();
            saveSettings();
        }
        
        // Add a new word
        function addNewWord(type) {
            const typeMap = {
                'wake': wakeWords,
                'sleep': sleepWords,
                'interrupt': interruptWords
            };
            
            const words = typeMap[type];
            if (!words) return;
            
            const newWord = prompt(`Add new ${type} word:`);
            
            if (newWord === null || newWord.trim() === '') {
                return; // User cancelled or entered empty text
            }
            
            const trimmedWord = newWord.trim().toLowerCase();
            
            // Check if the word already exists
            if (words.some(w => w.toLowerCase() === trimmedWord)) {
                alert('This word already exists in the list.');
                return;
            }
            
            words.push(trimmedWord);
            updateWakeWordsDisplay();
            saveSettings();
        }

        // Toggle Ollama settings visibility
        function toggleOllamaSettings() {
            const useOllama = document.getElementById('useOllama').checked;
            const ollamaSettings = document.getElementById('ollamaSettings');
            
            if (useOllama) {
                ollamaSettings.style.display = 'block';
            } else {
                ollamaSettings.style.display = 'none';
            }
        }

        // Toggle Spotify settings visibility
        function toggleSpotifySettings() {
            const useSpotify = document.getElementById('useSpotify').checked;
            const spotifySettings = document.getElementById('spotifySettings');
            
            if (useSpotify) {
                spotifySettings.style.display = 'block';
                // Update the redirect URI display when showing settings
                updateRedirectUriDisplay();
            } else {
                spotifySettings.style.display = 'none';
            }
        }

        // Update redirect URI display
        function updateRedirectUriDisplay() {
            const redirectUriElement = document.getElementById('currentRedirectUri');
            if (redirectUriElement) {
                const currentUri = window.location.origin + window.location.pathname;
                redirectUriElement.textContent = currentUri;
            }
        }

        // Update timeout display
        function updateTimeoutDisplay() {
            const timeoutSelect = document.getElementById('timeoutSelect');
            const timeoutDisplay = document.getElementById('timeoutDisplay');
            const timeoutValue = parseInt(timeoutSelect.value);
            const seconds = (timeoutValue / 1000).toFixed(1);
            
            timeoutDisplay.textContent = `Bot will wait ${seconds} seconds before listening again`;
            
            // Auto-save settings when timeout changes
            saveSettings();
        }

        // Update pitch display
        function updatePitchDisplay() {
            const pitchSelect = document.getElementById('botPitch');
            const pitchDisplay = document.getElementById('pitchDisplay');
            const pitchValue = pitchSelect.value;
            
            let pitchName = '';
            if (pitchValue <= 0.3) pitchName = 'Very Low';
            else if (pitchValue <= 0.5) pitchName = 'Low';
            else if (pitchValue <= 0.8) pitchName = 'Medium Low';
            else if (pitchValue <= 1.0) pitchName = 'Normal';
            else if (pitchValue <= 1.2) pitchName = 'Medium High';
            else if (pitchValue <= 1.5) pitchName = 'High';
            else if (pitchValue <= 1.8) pitchName = 'Very High';
            else pitchName = 'Extra High';
            
            pitchDisplay.textContent = `Current pitch: ${pitchValue} (${pitchName})`;
            
            // Auto-save settings when pitch changes
            saveSettings();
        }

        // Toggle mobile optimization
        function toggleMobileOptimization() {
            const enabled = document.getElementById('mobileOptimization').checked;
            const isMobile = detectMobileDevice();
            
            mobileOptimizationEnabled = enabled;
            
            // On mobile, push-to-talk is mandatory when optimization is enabled
            if (enabled && isMobile) {
                document.getElementById('mobilePushToTalk').checked = true;
            }
            
            const pushToTalkEnabled = document.getElementById('mobilePushToTalk').checked;
            const autoSleepDisabled = document.getElementById('disableMobileAutoSleep').checked;
            
            console.log('Mobile optimization:', enabled ? 'enabled' : 'disabled');
            console.log('Push-to-talk mode:', pushToTalkEnabled ? 'enabled' : 'disabled');
            console.log('Auto-sleep disabled:', autoSleepDisabled ? 'enabled' : 'disabled');
            
            // Show/hide mobile-specific settings
            const pushToTalkGroup = document.getElementById('mobilePushToTalkGroup');
            const autoSleepGroup = document.getElementById('mobileAutoSleepGroup');
            
            if (enabled) {
                // Hide push-to-talk option on mobile (it's mandatory)
                if (isMobile) {
                    pushToTalkGroup.style.display = 'none';
                } else {
                    pushToTalkGroup.style.display = 'block';
                }
                autoSleepGroup.style.display = 'block';
            } else {
                pushToTalkGroup.style.display = 'none';
                autoSleepGroup.style.display = 'none';
            }
            
            // Show/hide push-to-talk button based on mobile optimization and push-to-talk setting
            const pushToTalkBtn = document.getElementById('pushToTalkBtn');
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            if (enabled && (pushToTalkEnabled || isMobile)) {
                pushToTalkBtn.style.display = 'inline-block';
                if (isMobile) {
                    // On mobile, completely hide start/stop buttons
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'none';
                } else {
                    startBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'inline-block';
                }
                updateStatus('üé§ Push-to-Talk Mode', 'Activate assistant, then hold "Hold to Talk" button to speak');
            } else {
                pushToTalkBtn.style.display = 'none';
                startBtn.style.display = 'inline-block';
                stopBtn.style.display = 'inline-block';
            }
            
            // If bot is active, restart with new settings
            if (isBotActive) {
                console.log('Restarting bot with mobile optimization changes');
                
                // Stop current recognition
                if (speechRecognition) {
                    speechRecognition.stop();
                }
                
                // Clean up existing resources
                if (voiceActivityDetector) {
                    voiceActivityDetector = null;
                }
                
                // Restart after a moment
                setTimeout(() => {
                    if (isBotActive) {
                        initBot();
                        // Only start continuous listening if not mobile or push-to-talk not enabled
                        if (!isMobile && !pushToTalkEnabled) {
                            speechRecognition.start();
                        }
                        updateStatus('üîÑ Settings Updated', 'Mobile optimization ' + (enabled ? 'enabled' : 'disabled'));
                    }
                }, 1000);
            }
        }

        // Toggle mobile push-to-talk mode
        function toggleMobilePushToTalk() {
            toggleMobileOptimization(); // Use the main function that handles all mobile settings
        }

        // Add new command
        function addCommand() {
            const commandInput = document.getElementById('commandInput');
            const responseInput = document.getElementById('responseInput');
            
            const command = commandInput.value.trim().toLowerCase();
            const response = responseInput.value.trim();
            
            if (!command || !response) {
                alert('Please enter both a command and a response.');
                return;
            }
            
            // Add to userCommands
            if (!userCommands[command]) {
                userCommands[command] = [];
            }
            userCommands[command].push(response);
            
            // Clear inputs
            commandInput.value = '';
            responseInput.value = '';
            
            // Update displays
            updateCommandsDisplay();
            updateCommandsList();
            
            // Auto-save settings
            saveSettings();
            
            alert(`Command "${command}" added successfully!`);
        }

        // Clear all commands
        function clearAllCommands() {
            if (confirm('Are you sure you want to clear all custom commands? This cannot be undone.')) {
                userCommands = {
                    'hello': ['Hello! How can I help you today?'],
                    'help': ['You can add your own commands in the settings. Try saying hello, time, or date.']
                };
                updateCommandsDisplay();
                updateCommandsList();
                alert('All custom commands have been cleared. Time and date commands are built-in and always available.');
            }
        }

        // Update commands display
        function updateCommandsDisplay() {
            const display = document.getElementById('commandsDisplay');
            display.innerHTML = '';
            
            for (const [command, responses] of Object.entries(userCommands)) {
                const commandDiv = document.createElement('div');
                commandDiv.style.marginBottom = '10px';
                commandDiv.style.padding = '8px';
                commandDiv.style.background = '#f8f9fa';
                commandDiv.style.borderRadius = '5px';
                
                commandDiv.innerHTML = `
                    <strong>${command}</strong>
                    <button onclick="editCommand('${command}')" style="float: right; background: #3498db; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px; margin-left: 4px;">‚úèÔ∏è</button>
                    <button onclick="removeCommand('${command}')" style="float: right; background: #e74c3c; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px;">‚úï</button>
                    <br>
                    <small style="color: #666;">${responses.length} response(s)</small>
                `;
                
                display.appendChild(commandDiv);
            }
            
            if (Object.keys(userCommands).length === 0) {
                display.innerHTML = '<em style="color: #999;">No commands added yet</em>';
            }
        }

        // Remove command
        function removeCommand(command) {
            if (confirm(`Remove command "${command}"?`)) {
                delete userCommands[command];
                updateCommandsDisplay();
                updateCommandsList();
                
                // Auto-save settings
                saveSettings();
            }
        }
        
        // Edit command
        function editCommand(command) {
            const responses = userCommands[command];
            if (!responses) {
                alert('Command not found.');
                return;
            }
            
            const newCommand = prompt(`Edit command name:`, command);
            if (newCommand === null || newCommand.trim() === '') {
                return; // User cancelled or entered empty text
            }
            
            const normalizedNewCommand = newCommand.trim().toLowerCase();
            const normalizedOldCommand = command.toLowerCase();
            
            // Check if the new command name already exists (and it's different from the current one)
            if (normalizedNewCommand !== normalizedOldCommand && userCommands[normalizedNewCommand]) {
                alert('A command with that name already exists.');
                return;
            }
            
            const currentResponses = responses.join(', ');
            const newResponses = prompt(`Edit responses (comma-separated):`, currentResponses);
            if (newResponses === null) {
                return; // User cancelled
            }
            
            const responseArray = newResponses.split(',').map(r => r.trim()).filter(r => r.length > 0);
            if (responseArray.length === 0) {
                alert('Please provide at least one response.');
                return;
            }
            
            // Remove old command if name changed
            if (normalizedNewCommand !== normalizedOldCommand) {
                delete userCommands[command];
            }
            
            // Add/update command with new data
            userCommands[normalizedNewCommand] = responseArray;
            
            updateCommandsDisplay();
            updateCommandsList();
            saveSettings();
            
            alert(`Command "${normalizedNewCommand}" updated successfully!`);
        }

        // Update commands list in capabilities
        function updateCommandsList() {
            const commandsList = document.getElementById('commandsList');
            const commands = Object.keys(userCommands).join(', ');
            commandsList.textContent = commands || 'No commands';
        }

        // Test time response format
        function testTimeResponse() {
            const currentTime = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            const timeFormat = document.getElementById('timeResponseFormat').value || defaultSettings.timeResponseFormat;
            const testResponse = timeFormat.replace('{time}', currentTime);
            
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            
            const utterance = new SpeechSynthesisUtterance(testResponse);
            const voiceSelect = document.getElementById('botVoice').value;
            const speedSelect = document.getElementById('botSpeed').value;
            const pitchSelect = document.getElementById('botPitch').value;
            
            // Apply voice settings
            const voices = speechSynthesis.getVoices();
            let selectedVoice = voices.find(voice => voice.name === voiceSelect);
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            
            // Apply speed and pitch
            switch(speedSelect) {
                case 'slow': utterance.rate = 0.7; break;
                case 'medium': utterance.rate = 1.0; break;
                case 'fast': utterance.rate = 1.3; break;
            }
            
            utterance.pitch = parseFloat(pitchSelect);
            
            speechSynthesis.speak(utterance);
            alert(`Testing: "${testResponse}"`);
        }

        // Test date response format
        function testDateResponse() {
            const currentDate = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            const dateFormat = document.getElementById('dateResponseFormat').value || defaultSettings.dateResponseFormat;
            const testResponse = dateFormat.replace('{date}', currentDate);
            
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            
            const utterance = new SpeechSynthesisUtterance(testResponse);
            const voiceSelect = document.getElementById('botVoice').value;
            const speedSelect = document.getElementById('botSpeed').value;
            const pitchSelect = document.getElementById('botPitch').value;
            
            // Apply voice settings
            const voices = speechSynthesis.getVoices();
            let selectedVoice = voices.find(voice => voice.name === voiceSelect);
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            
            // Apply speed and pitch
            switch(speedSelect) {
                case 'slow': utterance.rate = 0.7; break;
                case 'medium': utterance.rate = 1.0; break;
                case 'fast': utterance.rate = 1.3; break;
            }
            
            utterance.pitch = parseFloat(pitchSelect);
            
            speechSynthesis.speak(utterance);
            alert(`Testing: "${testResponse}"`);
        }

        // Reset time and date formats to defaults
        function resetTimeeDateFormats() {
            if (confirm('Reset time and date response formats to defaults?')) {
                document.getElementById('timeResponseFormat').value = defaultSettings.timeResponseFormat;
                document.getElementById('dateResponseFormat').value = defaultSettings.dateResponseFormat;
                saveSettings();
                alert('Time and date formats reset to defaults.');
            }
        }

        // Initialize when page loads
        window.addEventListener('load', async () => {
            // Initialize intro video first
            initIntroVideo();
            
            // Load saved settings first
            const settingsLoaded = loadSettings();
            
            // Initialize mobile detection display
            const deviceTypeElement = document.getElementById('deviceType');
            if (deviceTypeElement) {
                deviceTypeElement.textContent = isMobileDevice ? 'Mobile Device' : 'Desktop/Laptop';
                deviceTypeElement.style.color = isMobileDevice ? '#00b894' : '#74b9ff';
                deviceTypeElement.style.fontWeight = 'bold';
            }
            
            // Set default mobile optimization if no settings were loaded
            if (!settingsLoaded) {
                document.getElementById('mobileOptimization').checked = isMobileDevice;
                mobileOptimizationEnabled = isMobileDevice;
                // Auto-enable push-to-talk on mobile
                if (isMobileDevice) {
                    document.getElementById('mobilePushToTalk').checked = true;
                }
            }
            
            // Update mobile controls display
            toggleMobileOptimization();
            
            // Set welcome message timestamp
            document.getElementById('welcome-time').textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            
            // Initialize microphone selection
            await populateMicrophoneSelect();
            
            // Initialize commands display
            updateCommandsDisplay();
            updateCommandsList();
            
            // Initialize words display
            updateWakeWordsDisplay();
            updateIndividualWordsDisplay();
            
            // Initialize pitch display
            updatePitchDisplay();
            
            // Initialize timeout display
            updateTimeoutDisplay();
            
            // Initialize wake words display and input fields
            updateWakeWordsDisplay();
            document.getElementById('wakeWordInput').value = wakeWords.join(', ');
            document.getElementById('sleepWordInput').value = sleepWords.join(', ');
            document.getElementById('interruptWordInput').value = interruptWords.join(', ');
            
            // Initialize absence greeting settings if not loaded from localStorage
            if (!settingsLoaded) {
                document.getElementById('useAbsenceGreeting').checked = defaultSettings.useAbsenceGreeting;
                document.getElementById('absenceMinutes').value = defaultSettings.absenceMinutes;
                document.getElementById('morningGreeting').value = defaultSettings.morningGreeting;
                document.getElementById('afternoonGreeting').value = defaultSettings.afternoonGreeting;
                document.getElementById('eveningGreeting').value = defaultSettings.eveningGreeting;
                document.getElementById('nightGreeting').value = defaultSettings.nightGreeting;
                document.getElementById('greetingCustomMessage').value = defaultSettings.greetingCustomMessage;
                document.getElementById('openSettingsPhrase').value = defaultSettings.openSettingsPhrase;
                document.getElementById('settingsPassword').value = defaultSettings.settingsPassword;
                
                document.getElementById('useReminders').checked = defaultSettings.useReminders;
                document.getElementById('requireReminderConfirmation').checked = defaultSettings.requireReminderConfirmation;
                document.getElementById('maxReminders').value = defaultSettings.maxReminders;
                document.getElementById('reminderSnooze').value = defaultSettings.reminderSnooze;
            }
            
            // Initialize reminder system
            loadRemindersFromStorage();
            
            // Load last interaction time
            const savedInteractionTime = localStorage.getItem('lastInteractionTime');
            if (savedInteractionTime) {
                lastInteractionTime = parseInt(savedInteractionTime);
            }
            
            // Start countdown timer for active reminders
            setInterval(updateCountdowns, 1000);
            
            // Initialize Ollama settings visibility
            toggleOllamaSettings();
            
            // Initialize Spotify settings visibility and redirect URI display
            toggleSpotifySettings();
            updateRedirectUriDisplay();
            
            // Add event listeners for auto-saving settings
            document.getElementById('botVoice').addEventListener('change', saveSettings);
            document.getElementById('botLanguage').addEventListener('change', saveSettings);
            document.getElementById('botSpeed').addEventListener('change', saveSettings);
            document.getElementById('useAbsenceGreeting').addEventListener('change', saveSettings);
            document.getElementById('absenceMinutes').addEventListener('change', saveSettings);
            document.getElementById('morningGreeting').addEventListener('change', saveSettings);
            document.getElementById('afternoonGreeting').addEventListener('change', saveSettings);
            document.getElementById('eveningGreeting').addEventListener('change', saveSettings);
            document.getElementById('nightGreeting').addEventListener('change', saveSettings);
            document.getElementById('greetingCustomMessage').addEventListener('change', saveSettings);
            document.getElementById('normalWakeResponses').addEventListener('change', saveSettings);
            document.getElementById('openSettingsPhrase').addEventListener('change', saveSettings);
            document.getElementById('useReminders').addEventListener('change', saveSettings);
            document.getElementById('requireReminderConfirmation').addEventListener('change', saveSettings);
            document.getElementById('maxReminders').addEventListener('change', saveSettings);
            document.getElementById('reminderSnooze').addEventListener('change', saveSettings);
            document.getElementById('missedReminderMessage').addEventListener('change', saveSettings);
            // Pitch and timeout already have auto-save in their update functions
            
            // Load voices for speech synthesis
            if ('speechSynthesis' in window) {
                let voices = speechSynthesis.getVoices();
                
                if (voices.length === 0) {
                    speechSynthesis.addEventListener('voiceschanged', () => {
                        voices = speechSynthesis.getVoices();
                        console.log('Available voices loaded:', voices.length);
                        console.log('Voice pitch support varies by voice and browser');
                    });
                } else {
                    console.log('Available voices:', voices.length);
                    console.log('Voice pitch support varies by voice and browser');
                }
            }
            
            if (settingsLoaded) {
                updateStatus('ü§ñ Advanced Assistant Ready', 'Settings loaded from previous session - ready for voice interaction');
            } else {
                updateStatus('ü§ñ Advanced Assistant Ready', 'Starting assistant automatically...');
            }
            
            // Automatically start the bot
            setTimeout(() => {
                startBot();
            }, 1000);
            
            // Automatically open fullscreen avatar view
            setTimeout(() => {
                openFullscreenAvatar();
            }, 1500);
        });

        // Make functions globally available
        window.startBot = startBot;
        window.stopBot = stopBot;
        window.testVoice = testVoice;
        window.addCommand = addCommand;
        window.clearAllCommands = clearAllCommands;
        window.removeCommand = removeCommand;
        window.updatePitchDisplay = updatePitchDisplay;
        window.updateTimeoutDisplay = updateTimeoutDisplay;
        window.updateWakeWords = updateWakeWords;
        window.resetWakeWords = resetWakeWords;
        window.exportSettings = exportSettings;
        window.importSettings = importSettings;
        window.resetAllSettings = resetAllSettings;
        window.toggleOllamaSettings = toggleOllamaSettings;
        window.testOllamaConnection = testOllamaConnection;
        window.openFullscreenAvatar = openFullscreenAvatar;
        window.closeFullscreenAvatar = closeFullscreenAvatar;
        window.openCameraView = openCameraView;
        window.closeCameraView = closeCameraView;
        window.startMotionDetection = startMotionDetection;
        window.stopMotionDetection = stopMotionDetection;
        window.toggleMotionDetection = toggleMotionDetection;
        window.openSmartView = openSmartView;
        window.closeSmartView = closeSmartView;
        window.skipIntro = skipIntro;
        window.toggleIntroSound = toggleIntroSound;
        window.listActiveReminders = listActiveReminders;
        window.clearAllReminders = clearAllReminders;
        window.cancelReminder = cancelReminder;
        window.testTimeResponse = testTimeResponse;
        window.testDateResponse = testDateResponse;
        window.resetTimeeDateFormats = resetTimeeDateFormats;
    </script>
    
    <!-- Fullscreen Avatar Overlay -->
    <div class="fullscreen-overlay" id="fullscreenOverlay">
        <div class="back-btn" style="display: none;" onclick="closeFullscreenAvatar()">‚Üê</div>
        <div class="settings-btn" style="display: none;" title="Say 'open settings' to access settings">‚öôÔ∏è</div>
        <div class="lock-btn" onclick="openSettingsWithPassword()" title="Settings (Password Required)">üîí</div>
        
        <!-- Camera View -->
        <div class="camera-container" id="cameraContainer" style="display: none;">
            <div class="camera-header">
                <span id="cameraStatus">Looking at you üëÅÔ∏è</span>
                <button class="camera-close-btn" onclick="closeCameraView()">√ó</button>
            </div>
            <video id="cameraVideo" autoplay muted playsinline></video>
            <div class="camera-controls">
                <button class="camera-btn" onclick="closeCameraView()">Stop Looking</button>
                <button class="camera-btn motion-btn" id="motionToggleBtn" onclick="toggleMotionDetection()" style="background: linear-gradient(135deg, #00b894, #00cec9); display: none;">üéØ Start Motion Detection</button>
                <div class="detection-info" id="detectionInfo" style="display: none;">
                    <small>üß† AI Vision Ready</small>
                </div>
                <div class="motion-info" id="motionInfo" style="display: none;">
                    <small>üîç Motion Monitoring Active</small>
                </div>
            </div>
        </div>
        
        <div class="fullscreen-avatar idle" id="fullscreenAvatar">ü§ñ</div>
        <div class="fullscreen-status" id="fullscreenStatus">Advanced Assistant Ready</div>
        <div class="fullscreen-substatus" id="fullscreenSubstatus">Your intelligent voice companion</div>
        <div class="fullscreen-hint">Say "Hey Bot" or other wake words to start ‚Ä¢ Use "Stop" to interrupt</div>
    </div>
    
    <!-- Smart View Overlay -->
    <div class="smart-view-overlay" id="smartViewOverlay">
        <div class="smart-view-header">
            <button class="smart-close-btn" onclick="closeSmartView()">‚Üê Back to Assistant</button>
            <div class="smart-instructions">
                Press 'i' to import images ‚Ä¢ Use hand gestures to interact ‚Ä¢ Say "close smart view" to exit
            </div>
        </div>
        <div class="smart-view-content" id="smartViewContent">
            <!-- Smart UI content will be loaded here -->
        </div>
    </div>

    <script>
        // Initialize Spotify token check on page load
        document.addEventListener('DOMContentLoaded', function() {
            checkForSpotifyToken();
            initializeMobileControls();
        });
        
        // Initialize mobile controls on page load
        function initializeMobileControls() {
            // This function is called from DOMContentLoaded to set up mobile controls
            // The actual initialization happens in the main init block above
            toggleMobileOptimization();
        }
    </script>
</body>
</html>